1365934193
2 2
13 libp3interval 4 ceEZ 8 p3direct 
161
171 8 get_name 0 4 332 19 CInterval::get_name 0 1 1 732
// Filename: cInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_name
//       Access: Published
//  Description: Returns the interval's name.
////////////////////////////////////////////////////////////////////
67
inline basic_string< char > const &CInterval::get_name(void) const;

172 12 get_duration 0 4 332 23 CInterval::get_duration 0 1 2 271
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_duration
//       Access: Published
//  Description: Returns the duration of the interval in seconds.
////////////////////////////////////////////////////////////////////
50
inline double CInterval::get_duration(void) const;

173 14 get_open_ended 0 4 332 25 CInterval::get_open_ended 0 1 3 685
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_open_ended
//       Access: Published
//  Description: Returns the state of the "open_ended" flag.  This is
//               primarily intended for instantaneous intervals like
//               FunctionIntervals; it indicates true if the interval
//               has some lasting effect that should be applied even
//               if the interval doesn't get started until after its
//               finish time, or false if the interval is a transitive
//               thing that doesn't need to be called late.
////////////////////////////////////////////////////////////////////
50
inline bool CInterval::get_open_ended(void) const;

174 9 get_state 0 4 332 20 CInterval::get_state 0 1 4 385
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_state
//       Access: Published
//  Description: Indicates the state the interval believes it is in:
//               whether it has been started, is currently in the
//               middle, or has been finalized.
////////////////////////////////////////////////////////////////////
57
inline CInterval::State CInterval::get_state(void) const;

175 10 is_stopped 0 4 332 21 CInterval::is_stopped 0 1 5 364
////////////////////////////////////////////////////////////////////
//     Function: CInterval::is_stopped
//       Access: Published
//  Description: Returns true if the interval is in either its initial
//               or final states (but not in a running or paused
//               state).
////////////////////////////////////////////////////////////////////
46
inline bool CInterval::is_stopped(void) const;

176 14 set_done_event 0 4 332 25 CInterval::set_done_event 0 1 6 426
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_done_event
//       Access: Published
//  Description: Sets the event that is generated whenever the
//               interval reaches its final state, whether it is
//               explicitly finished or whether it gets there on its
//               own.
////////////////////////////////////////////////////////////////////
73
inline void CInterval::set_done_event(basic_string< char > const &event);

177 14 get_done_event 0 4 332 25 CInterval::get_done_event 0 1 7 429
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_done_event
//       Access: Published
//  Description: Returns the event that is generated whenever the
//               interval reaches its final state, whether it is
//               explicitly finished or whether it gets there on its
//               own.
////////////////////////////////////////////////////////////////////
73
inline basic_string< char > const &CInterval::get_done_event(void) const;

178 5 set_t 0 4 332 16 CInterval::set_t 0 1 8 450
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_t
//       Access: Published
//  Description: Explicitly sets the time within the interval.
//               Normally, you would use start() .. finish() to let
//               the time play normally, but this may be used to set
//               the time to some particular value.
////////////////////////////////////////////////////////////////////
32
void CInterval::set_t(double t);

179 5 get_t 0 4 332 16 CInterval::get_t 0 1 9 373
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_t
//       Access: Published
//  Description: Returns the current time of the interval: the last
//               value of t passed to priv_initialize(), priv_step(), or
//               priv_finalize().
////////////////////////////////////////////////////////////////////
43
inline double CInterval::get_t(void) const;

180 14 set_auto_pause 0 4 332 25 CInterval::set_auto_pause 0 1 10 624
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_auto_pause
//       Access: Published
//  Description: Changes the state of the 'auto_pause' flag.  If
//               this is true, the interval may be arbitrarily
//               interrupted when the system needs to reset due to
//               some external event by calling
//               CIntervalManager::interrupt().  If this
//               is false (the default), the interval must always be
//               explicitly finished or paused.
////////////////////////////////////////////////////////////////////
55
inline void CInterval::set_auto_pause(bool auto_pause);

181 14 get_auto_pause 0 4 332 25 CInterval::get_auto_pause 0 1 11 308
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_auto_pause
//       Access: Published
//  Description: Returns the state of the 'auto_pause' flag.  See
//               set_auto_pause().
////////////////////////////////////////////////////////////////////
50
inline bool CInterval::get_auto_pause(void) const;

182 15 set_auto_finish 0 4 332 26 CInterval::set_auto_finish 0 1 12 623
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_auto_finish
//       Access: Published
//  Description: Changes the state of the 'auto_finish' flag.  If
//               this is true, the interval may be arbitrarily
//               finished when the system needs to reset due to
//               some external event by calling
//               CIntervalManager::interrupt().  If this
//               is false (the default), the interval must always be
//               explicitly finished or paused.
////////////////////////////////////////////////////////////////////
57
inline void CInterval::set_auto_finish(bool auto_finish);

183 15 get_auto_finish 0 4 332 26 CInterval::get_auto_finish 0 1 13 311
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_auto_finish
//       Access: Published
//  Description: Returns the state of the 'auto_finish' flag.  See
//               set_auto_finish().
////////////////////////////////////////////////////////////////////
51
inline bool CInterval::get_auto_finish(void) const;

184 20 set_wants_t_callback 0 4 332 31 CInterval::set_wants_t_callback 0 1 14 533
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_wants_t_callback
//       Access: Published
//  Description: Changes the state of the 'wants_t_callback' flag.  If
//               this is true, the interval will be returned by
//               CIntervalManager::get_event() each time the
//               interval's time value has been changed, regardless of
//               whether it has any external events.
////////////////////////////////////////////////////////////////////
67
inline void CInterval::set_wants_t_callback(bool wants_t_callback);

185 20 get_wants_t_callback 0 4 332 31 CInterval::get_wants_t_callback 0 1 15 325
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_wants_t_callback
//       Access: Published
//  Description: Returns the state of the 'wants_t_callback' flag.
//               See set_wants_t_callback().
////////////////////////////////////////////////////////////////////
56
inline bool CInterval::get_wants_t_callback(void) const;

186 11 set_manager 0 4 332 22 CInterval::set_manager 0 1 16 523
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_manager
//       Access: Published
//  Description: Indicates the CIntervalManager object which will be
//               responsible for playing this interval.  This defaults
//               to the global CIntervalManager; you should need to
//               change this only if you have special requirements for
//               playing this interval.
////////////////////////////////////////////////////////////////////
62
inline void CInterval::set_manager(CIntervalManager *manager);

187 11 get_manager 0 4 332 22 CInterval::get_manager 0 1 17 604
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_manager
//       Access: Published
//  Description: Returns the CIntervalManager object which will be
//               responsible for playing this interval.  Note that
//               this can only return a C++ object; if the particular
//               CIntervalManager object has been extended in the
//               scripting language, this will return the encapsulated
//               C++ object, not the full extended object.
////////////////////////////////////////////////////////////////////
60
inline CIntervalManager *CInterval::get_manager(void) const;

188 5 start 0 4 332 16 CInterval::start 0 4 18 19 20 21 478
////////////////////////////////////////////////////////////////////
//     Function: CInterval::start
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play to the end and stop.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
////////////////////////////////////////////////////////////////////
89
void CInterval::start(double start_t = (0), double end_t = (-1), double play_rate = (1));

189 4 loop 0 4 332 15 CInterval::loop 0 4 22 23 24 25 587
////////////////////////////////////////////////////////////////////
//     Function: CInterval::loop
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play until it is interrupted with finish() or
//               pause(), looping back to start_t when it reaches
//               end_t.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
////////////////////////////////////////////////////////////////////
88
void CInterval::loop(double start_t = (0), double end_t = (-1), double play_rate = (1));

190 5 pause 0 4 332 16 CInterval::pause 0 1 26 379
////////////////////////////////////////////////////////////////////
//     Function: CInterval::pause
//       Access: Published
//  Description: Stops the interval from playing but leaves it in its
//               current state.  It may later be resumed from this
//               point by calling resume().
////////////////////////////////////////////////////////////////////
30
double CInterval::pause(void);

191 6 resume 0 4 332 17 CInterval::resume 0 2 27 28 628
////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume
//       Access: Published
//  Description: Restarts the interval from its current point after a
//               previous call to pause().
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume
//       Access: Published
//  Description: Restarts the interval from the indicated point after a
//               previous call to pause().
////////////////////////////////////////////////////////////////////
69
void CInterval::resume(void);
void CInterval::resume(double start_t);

192 12 resume_until 0 4 332 23 CInterval::resume_until 0 1 29 440
////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume_until
//       Access: Published
//  Description: Restarts the interval from the current point after a
//               previous call to pause() (or a previous
//               play-to-point-and-stop), to play until the indicated
//               point and then stop.
////////////////////////////////////////////////////////////////////
43
void CInterval::resume_until(double end_t);

193 6 finish 0 4 332 17 CInterval::finish 0 1 30 297
////////////////////////////////////////////////////////////////////
//     Function: CInterval::finish
//       Access: Published
//  Description: Stops the interval from playing and sets it to its
//               final state.
////////////////////////////////////////////////////////////////////
29
void CInterval::finish(void);

194 16 clear_to_initial 0 4 332 27 CInterval::clear_to_initial 0 1 31 551
////////////////////////////////////////////////////////////////////
//     Function: CInterval::clear_to_initial
//       Access: Published
//  Description: Pauses the interval, if it is playing, and resets its
//               state to its initial state, abandoning any state
//               changes already in progress in the middle of the
//               interval.  Calling this is like pausing the interval
//               and discarding it, creating a new one in its place.
////////////////////////////////////////////////////////////////////
39
void CInterval::clear_to_initial(void);

195 10 is_playing 0 4 332 21 CInterval::is_playing 0 1 32 305
////////////////////////////////////////////////////////////////////
//     Function: CInterval::is_playing
//       Access: Published
//  Description: Returns true if the interval is currently playing,
//               false otherwise.
////////////////////////////////////////////////////////////////////
39
bool CInterval::is_playing(void) const;

196 13 get_play_rate 0 4 332 24 CInterval::get_play_rate 0 1 33 326
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_play_rate
//       Access: Published
//  Description: Returns the play rate as set by the last call to
//               start(), loop(), or set_play_rate().
////////////////////////////////////////////////////////////////////
44
double CInterval::get_play_rate(void) const;

197 13 set_play_rate 0 4 332 24 CInterval::set_play_rate 0 1 34 529
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_play_rate
//       Access: Published
//  Description: Changes the play rate of the interval.  If the
//               interval is already started, this changes its speed
//               on-the-fly.  Note that since play_rate is a parameter
//               to start() and loop(), the next call to start() or
//               loop() will reset this parameter.
////////////////////////////////////////////////////////////////////
48
void CInterval::set_play_rate(double play_rate);

198 13 priv_do_event 0 4 332 24 CInterval::priv_do_event 0 1 35 709
// These functions control the actual playback of the interval.
// Don't call them directly; they're intended to be called from a
// supervising object, e.g. the Python start() .. finish()
// interface.
// These cannot be declared private because they must be accessible
// to Python, but the method names are prefixed with priv_ to remind
// you that you probably don't want to be using them directly.

////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_do_event
//       Access: Published
//  Description: Calls the appropriate event function indicated by the
//               EventType.
////////////////////////////////////////////////////////////////////
68
void CInterval::priv_do_event(double t, CInterval::EventType event);

199 15 priv_initialize 0 4 332 26 CInterval::priv_initialize 0 1 36 889
// These functions control the actual playback of the interval.
// Don't call them directly; they're intended to be called from a
// supervising object, e.g. the Python start() .. finish()
// interface.
// These cannot be declared private because they must be accessible
// to Python, but the method names are prefixed with priv_ to remind
// you that you probably don't want to be using them directly.

////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_initialize
//       Access: Published, Virtual
//  Description: This replaces the first call to priv_step(), and indicates
//               that the interval has just begun.  This may be
//               overridden by derived classes that need to do some
//               explicit initialization on the first call.
////////////////////////////////////////////////////////////////////
50
virtual void CInterval::priv_initialize(double t);

200 12 priv_instant 0 4 332 23 CInterval::priv_instant 0 1 37 486
////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_instant
//       Access: Published, Virtual
//  Description: This is called in lieu of priv_initialize() .. priv_step()
//               .. priv_finalize(), when everything is to happen within
//               one frame.  The interval should initialize itself,
//               then leave itself in the final state.
////////////////////////////////////////////////////////////////////
43
virtual void CInterval::priv_instant(void);

201 9 priv_step 0 4 332 20 CInterval::priv_step 0 1 38 409
////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_step
//       Access: Published, Virtual
//  Description: Advances the time on the interval.  The time may
//               either increase (the normal case) or decrease
//               (e.g. if the interval is being played by a slider).
////////////////////////////////////////////////////////////////////
44
virtual void CInterval::priv_step(double t);

202 13 priv_finalize 0 4 332 24 CInterval::priv_finalize 0 1 39 439
////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_finalize
//       Access: Published, Virtual
//  Description: This is called to stop an interval, forcing it to
//               whatever state it would be after it played all the
//               way through.  It's generally invoked by
//               set_final_t().
////////////////////////////////////////////////////////////////////
44
virtual void CInterval::priv_finalize(void);

203 23 priv_reverse_initialize 0 4 332 34 CInterval::priv_reverse_initialize 0 1 40 485
////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_initialize
//       Access: Published, Virtual
//  Description: Similar to priv_initialize(), but this is called when the
//               interval is being played backwards; it indicates that
//               the interval should start at the finishing state and
//               undo any intervening intervals.
////////////////////////////////////////////////////////////////////
58
virtual void CInterval::priv_reverse_initialize(double t);

204 20 priv_reverse_instant 0 4 332 31 CInterval::priv_reverse_instant 0 1 41 524
////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_instant
//       Access: Published, Virtual
//  Description: This is called in lieu of priv_reverse_initialize()
//               .. priv_step() .. priv_reverse_finalize(), when everything is
//               to happen within one frame.  The interval should
//               initialize itself, then leave itself in the initial
//               state.
////////////////////////////////////////////////////////////////////
51
virtual void CInterval::priv_reverse_instant(void);

205 21 priv_reverse_finalize 0 4 332 32 CInterval::priv_reverse_finalize 0 1 42 393
////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_finalize
//       Access: Published, Virtual
//  Description: Called generally following a priv_reverse_initialize(),
//               this indicates the interval should set itself to the
//               initial state.
////////////////////////////////////////////////////////////////////
52
virtual void CInterval::priv_reverse_finalize(void);

206 14 priv_interrupt 0 4 332 25 CInterval::priv_interrupt 0 1 43 812
////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_interrupt
//       Access: Published, Virtual
//  Description: This is called while the interval is playing to
//               indicate that it is about to be interrupted; that is,
//               priv_step() will not be called for a length of time.  But
//               the interval should remain in its current state in
//               anticipation of being eventually restarted when the
//               calls to priv_step() eventually resume.
//
//               The purpose of this function is to allow self-running
//               intervals like sound intervals to stop the actual
//               sound playback during the pause.
////////////////////////////////////////////////////////////////////
45
virtual void CInterval::priv_interrupt(void);

207 6 output 0 4 332 17 CInterval::output 0 1 44 226
////////////////////////////////////////////////////////////////////
//     Function: CInterval::output
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
51
virtual void CInterval::output(ostream &out) const;

208 5 write 0 4 332 16 CInterval::write 0 1 45 225
////////////////////////////////////////////////////////////////////
//     Function: CInterval::write
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
68
virtual void CInterval::write(ostream &out, int indent_level) const;

209 10 setup_play 0 4 332 21 CInterval::setup_play 0 1 46 831
////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_play
//       Access: Published
//  Description: Called to prepare the interval for automatic timed
//               playback, e.g. via a Python task.  The interval will
//               be played from start_t to end_t, at a time factor
//               specified by play_rate.  start_t must always be less
//               than end_t (except for the exception for end_t == -1,
//               below), but if play_rate is negative the interval
//               will be played backwards.
//
//               Specify end_t of -1 to play the entire interval from
//               start_t.
//
//               Call step_play() repeatedly to execute the interval.
////////////////////////////////////////////////////////////////////
95
void CInterval::setup_play(double start_time, double end_time, double play_rate, bool do_loop);

210 12 setup_resume 0 4 332 23 CInterval::setup_resume 0 1 47 366
////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_resume
//       Access: Published
//  Description: Called to prepare the interval for restarting at the
//               current point within the interval after an
//               interruption.
////////////////////////////////////////////////////////////////////
35
void CInterval::setup_resume(void);

211 18 setup_resume_until 0 4 332 29 CInterval::setup_resume_until 0 1 48 470
////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_resume_until
//       Access: Published
//  Description: Called to prepare the interval for restarting from
//               the current point after a previous call to pause()
//               (or a previous play-to-point-and-stop), to play until
//               the indicated point and then stop.
////////////////////////////////////////////////////////////////////
49
void CInterval::setup_resume_until(double end_t);

212 9 step_play 0 4 332 20 CInterval::step_play 0 1 49 453
////////////////////////////////////////////////////////////////////
//     Function: CInterval::step_play
//       Access: Published
//  Description: Should be called once per frame to execute the
//               automatic timed playback begun with setup_play().
//
//               Returns true if the interval should continue, false
//               if it is done and should stop.
////////////////////////////////////////////////////////////////////
32
bool CInterval::step_play(void);

213 14 get_class_type 0 4 332 25 CInterval::get_class_type 0 1 50 0
50
static TypeHandle CInterval::get_class_type(void);

214 18 get_bogus_variable 0 20 336 39 CConstraintInterval::get_bogus_variable 0 1 52 52
getter for bool CConstraintInterval::bogus_variable;
57
bool CConstraintInterval::get_bogus_variable(void) const;

215 18 set_bogus_variable 0 36 336 39 CConstraintInterval::set_bogus_variable 0 1 53 52
setter for bool CConstraintInterval::bogus_variable;
57
void CConstraintInterval::set_bogus_variable(bool value);

216 14 get_class_type 0 4 336 35 CConstraintInterval::get_class_type 0 1 51 0
60
static TypeHandle CConstraintInterval::get_class_type(void);

217 20 ~CConstraintInterval 0 4 336 41 CConstraintInterval::~CConstraintInterval 0 0 0
48
CConstraintInterval::~CConstraintInterval(void);

218 21 CConstrainHprInterval 0 4 338 44 CConstrainHprInterval::CConstrainHprInterval 0 2 54 55 682
////////////////////////////////////////////////////////////////////
//     Function: CConstrainHprInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the orientation of one node to the orientation of
//               another, possibly with an added rotation.
//
//               If wrt is true, the node's orientation will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the target
//               node's local orientation will be copied unaltered.
////////////////////////////////////////////////////////////////////
193
CConstrainHprInterval::CConstrainHprInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const hprOffset = ((zero())));

219 8 get_node 0 4 338 31 CConstrainHprInterval::get_node 0 1 56 754
// Filename: cConstrainHprInterval.I
// Created by:  pratt (10Mar08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainHprInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
////////////////////////////////////////////////////////////////////
67
inline NodePath const &CConstrainHprInterval::get_node(void) const;

220 10 get_target 0 4 338 33 CConstrainHprInterval::get_target 0 1 57 259
////////////////////////////////////////////////////////////////////
//     Function: CConstrainHprInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
////////////////////////////////////////////////////////////////////
69
inline NodePath const &CConstrainHprInterval::get_target(void) const;

221 14 get_class_type 0 4 338 37 CConstrainHprInterval::get_class_type 0 1 58 0
62
static TypeHandle CConstrainHprInterval::get_class_type(void);

222 22 ~CConstrainHprInterval 0 4 338 45 CConstrainHprInterval::~CConstrainHprInterval 0 0 0
52
CConstrainHprInterval::~CConstrainHprInterval(void);

223 24 CConstrainPosHprInterval 0 4 339 50 CConstrainPosHprInterval::CConstrainPosHprInterval 0 3 59 60 61 720
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the position and orientation of one node to the
//               position and orientation of another.
//
//               If wrt is true, the node's position and orientation
//               will be transformed into the target node's parent's
//               space before being copied.  If wrt is false, the
//               target node's local position and orientation will be
//               copied unaltered.
////////////////////////////////////////////////////////////////////
240
CConstrainPosHprInterval::CConstrainPosHprInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const posOffset = ((zero())), LVecBase3f const hprOffset = ((zero())));

224 8 get_node 0 4 339 34 CConstrainPosHprInterval::get_node 0 1 62 760
// Filename: cConstrainPosHprInterval.I
// Created by:  pratt (10Mar08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
////////////////////////////////////////////////////////////////////
70
inline NodePath const &CConstrainPosHprInterval::get_node(void) const;

225 10 get_target 0 4 339 36 CConstrainPosHprInterval::get_target 0 1 63 262
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
////////////////////////////////////////////////////////////////////
72
inline NodePath const &CConstrainPosHprInterval::get_target(void) const;

226 14 get_class_type 0 4 339 40 CConstrainPosHprInterval::get_class_type 0 1 64 0
65
static TypeHandle CConstrainPosHprInterval::get_class_type(void);

227 25 ~CConstrainPosHprInterval 0 4 339 51 CConstrainPosHprInterval::~CConstrainPosHprInterval 0 0 0
58
CConstrainPosHprInterval::~CConstrainPosHprInterval(void);

228 21 CConstrainPosInterval 0 4 340 44 CConstrainPosInterval::CConstrainPosInterval 0 2 65 66 620
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the position of one node to the position of another.
//
//               If wrt is true, the node's position will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the target
//               node's local position will be copied unaltered.
////////////////////////////////////////////////////////////////////
193
CConstrainPosInterval::CConstrainPosInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const posOffset = ((zero())));

229 8 get_node 0 4 340 31 CConstrainPosInterval::get_node 0 1 67 754
// Filename: cConstrainPosInterval.I
// Created by:  pratt (29Sep06)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
////////////////////////////////////////////////////////////////////
67
inline NodePath const &CConstrainPosInterval::get_node(void) const;

230 10 get_target 0 4 340 33 CConstrainPosInterval::get_target 0 1 68 259
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
////////////////////////////////////////////////////////////////////
69
inline NodePath const &CConstrainPosInterval::get_target(void) const;

231 14 get_class_type 0 4 340 37 CConstrainPosInterval::get_class_type 0 1 69 0
62
static TypeHandle CConstrainPosInterval::get_class_type(void);

232 22 ~CConstrainPosInterval 0 4 340 45 CConstrainPosInterval::~CConstrainPosInterval 0 0 0
52
CConstrainPosInterval::~CConstrainPosInterval(void);

233 27 CConstrainTransformInterval 0 4 341 56 CConstrainTransformInterval::CConstrainTransformInterval 0 1 70 700
////////////////////////////////////////////////////////////////////
//     Function: CConstrainTransformInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the transform of one node to the transform of another.
//               To clarify, the transform of node will be copied to target.
//
//               If wrt is true, the node's transform will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the node's
//               local transform will be copied unaltered.
////////////////////////////////////////////////////////////////////
164
CConstrainTransformInterval::CConstrainTransformInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt);

234 8 get_node 0 4 341 37 CConstrainTransformInterval::get_node 0 1 71 766
// Filename: cConstrainTransformInterval.I
// Created by:  pratt (29Sep06)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainTransformInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
////////////////////////////////////////////////////////////////////
73
inline NodePath const &CConstrainTransformInterval::get_node(void) const;

235 10 get_target 0 4 341 39 CConstrainTransformInterval::get_target 0 1 72 265
////////////////////////////////////////////////////////////////////
//     Function: CConstrainTransformInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
////////////////////////////////////////////////////////////////////
75
inline NodePath const &CConstrainTransformInterval::get_target(void) const;

236 14 get_class_type 0 4 341 43 CConstrainTransformInterval::get_class_type 0 1 73 0
68
static TypeHandle CConstrainTransformInterval::get_class_type(void);

237 28 ~CConstrainTransformInterval 0 4 341 57 CConstrainTransformInterval::~CConstrainTransformInterval 0 0 0
64
CConstrainTransformInterval::~CConstrainTransformInterval(void);

238 16 CIntervalManager 0 4 342 34 CIntervalManager::CIntervalManager 0 1 74 229
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
41
CIntervalManager::CIntervalManager(void);

239 17 ~CIntervalManager 0 4 342 35 CIntervalManager::~CIntervalManager 0 0 228
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::Destructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
42
CIntervalManager::~CIntervalManager(void);

240 15 set_event_queue 0 4 342 33 CIntervalManager::set_event_queue 0 1 75 1195
// Filename: cIntervalManager.I
// Created by:  drose (10Sep02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::set_event_queue
//       Access: Published
//  Description: Specifies a custom event queue to be used for
//               throwing done events from intervals as they finish.
//               If this is not specified, the global event queue is
//               used.
//
//               The caller maintains ownership of the EventQueue
//               object; it is the caller's responsibility to ensure
//               that the supplied EventQueue does not destruct during
//               the lifetime of the CIntervalManager.
////////////////////////////////////////////////////////////////////
71
inline void CIntervalManager::set_event_queue(EventQueue *event_queue);

241 15 get_event_queue 0 4 342 33 CIntervalManager::get_event_queue 0 1 76 347
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_event_queue
//       Access: Published
//  Description: Returns the custom event queue to be used for
//               throwing done events from intervals as they finish.
////////////////////////////////////////////////////////////////////
65
inline EventQueue *CIntervalManager::get_event_queue(void) const;

242 14 add_c_interval 0 4 342 32 CIntervalManager::add_c_interval 0 1 77 1079
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::add_c_interval
//       Access: Published
//  Description: Adds the interval to the manager, and returns a
//               unique index for the interval.  This index will be
//               unique among all the currently added intervals, but
//               not unique across all intervals ever added to the
//               manager.  The maximum index value will never exceed
//               the maximum number of intervals added at any given
//               time.
//
//               If the external flag is true, the interval is
//               understood to also be stored in the scripting
//               language data structures.  In this case, it will be
//               available for information returned by
//               get_next_event() and get_next_removal().  If external
//               is false, the interval's index will never be returned
//               by these two functions.
////////////////////////////////////////////////////////////////////
73
int CIntervalManager::add_c_interval(CInterval *interval, bool external);

243 15 find_c_interval 0 4 342 33 CIntervalManager::find_c_interval 0 1 78 356
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::find_c_interval
//       Access: Published
//  Description: Returns the index associated with the named interval,
//               if there is such an interval, or -1 if there is not.
////////////////////////////////////////////////////////////////////
78
int CIntervalManager::find_c_interval(basic_string< char > const &name) const;

244 14 get_c_interval 0 4 342 32 CIntervalManager::get_c_interval 0 1 79 285
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_c_interval
//       Access: Published
//  Description: Returns the interval associated with the given index.
////////////////////////////////////////////////////////////////////
61
CInterval *CIntervalManager::get_c_interval(int index) const;

245 17 remove_c_interval 0 4 342 35 CIntervalManager::remove_c_interval 0 1 80 472
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::remove_c_interval
//       Access: Published
//  Description: Removes the indicated interval from the queue
//               immediately.  It will not be returned from
//               get_next_removal(), and none of its pending events,
//               if any, will be returned by get_next_event().
////////////////////////////////////////////////////////////////////
52
void CIntervalManager::remove_c_interval(int index);

246 9 interrupt 0 4 342 27 CIntervalManager::interrupt 0 1 81 605
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::interrupt
//       Access: Published
//  Description: Pauses or finishes (removes from the active queue)
//               all intervals tagged with auto_pause or auto_finish
//               set to true.  These are intervals that someone fired
//               up but won't necessarily expect to clean up; they can
//               be interrupted at will when necessary.
//
//               Returns the number of intervals affected.
////////////////////////////////////////////////////////////////////
38
int CIntervalManager::interrupt(void);

247 17 get_num_intervals 0 4 342 35 CIntervalManager::get_num_intervals 0 1 82 284
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_num_intervals
//       Access: Published
//  Description: Returns the number of currently active intervals.
////////////////////////////////////////////////////////////////////
52
int CIntervalManager::get_num_intervals(void) const;

248 13 get_max_index 0 4 342 31 CIntervalManager::get_max_index 0 1 83 591
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_max_index
//       Access: Published
//  Description: Returns one more than the largest interval index
//               number in the manager.  If you walk through all the
//               values between (0, get_max_index()] and call
//               get_c_interval() on each number, you will retrieve
//               all of the managed intervals (and possibly a number
//               of NULL pointers as well).
////////////////////////////////////////////////////////////////////
48
int CIntervalManager::get_max_index(void) const;

249 4 step 0 4 342 22 CIntervalManager::step 0 1 84 771
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::step
//       Access: Published
//  Description: This should be called every frame to do the
//               processing for all the active intervals.  It will
//               call step_play() for each interval that has been
//               added and that has not yet been removed.
//
//               After each call to step(), the scripting language
//               should call get_next_event() and get_next_removal()
//               repeatedly to process all the high-level
//               (e.g. Python-interval-based) events and to manage the
//               high-level list of intervals.
////////////////////////////////////////////////////////////////////
34
void CIntervalManager::step(void);

250 14 get_next_event 0 4 342 32 CIntervalManager::get_next_event 0 1 85 911
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_next_event
//       Access: Published
//  Description: This should be called by the scripting language after
//               each call to step().  It returns the index number of
//               the next interval that has events requiring servicing
//               by the scripting language, or -1 if no more intervals
//               have any events pending.
//
//               If this function returns something other than -1, it
//               is the scripting language's responsibility to query
//               the indicated interval for its next event via
//               get_event_index(), and eventually pop_event().
//
//               Then get_next_event() should be called again until it
//               returns -1.
////////////////////////////////////////////////////////////////////
43
int CIntervalManager::get_next_event(void);

251 16 get_next_removal 0 4 342 34 CIntervalManager::get_next_removal 0 1 86 694
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_next_removal
//       Access: Published
//  Description: This should be called by the scripting language after
//               each call to step().  It returns the index number of
//               an interval that was recently removed, or -1 if no
//               intervals were removed.
//
//               If this returns something other than -1, the
//               scripting language should clean up its own data
//               structures accordingly, and then call
//               get_next_removal() again.
////////////////////////////////////////////////////////////////////
45
int CIntervalManager::get_next_removal(void);

252 6 output 0 4 342 24 CIntervalManager::output 0 1 87 224
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
50
void CIntervalManager::output(ostream &out) const;

253 5 write 0 4 342 23 CIntervalManager::write 0 1 88 223
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::write
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
49
void CIntervalManager::write(ostream &out) const;

254 14 get_global_ptr 0 4 342 32 CIntervalManager::get_global_ptr 0 1 89 319
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_global_ptr
//       Access: Published, Static
//  Description: Returns the pointer to the one global
//               CIntervalManager object.
////////////////////////////////////////////////////////////////////
64
static CIntervalManager *CIntervalManager::get_global_ptr(void);

255 14 get_blend_type 0 4 343 29 CLerpInterval::get_blend_type 0 1 90 411
////////////////////////////////////////////////////////////////////
//     Function: CLerpInterval::get_blend_type
//       Access: Published
//  Description: Returns the blend type specified for the interval.
//               This controls how the linear interpolation behaves
//               near the beginning and end of the lerp period.
////////////////////////////////////////////////////////////////////
74
inline CLerpInterval::BlendType CLerpInterval::get_blend_type(void) const;

256 17 string_blend_type 0 4 343 32 CLerpInterval::string_blend_type 0 1 91 403
////////////////////////////////////////////////////////////////////
//     Function: CLerpInterval::string_blend_type
//       Access: Published, Static
//  Description: Returns the BlendType enumerated value corresponding
//               to the indicated string, or BT_invalid if the string
//               doesn't match anything.
////////////////////////////////////////////////////////////////////
105
static CLerpInterval::BlendType CLerpInterval::string_blend_type(basic_string< char > const &blend_type);

257 14 get_class_type 0 4 343 29 CLerpInterval::get_class_type 0 1 92 0
54
static TypeHandle CLerpInterval::get_class_type(void);

258 14 ~CLerpInterval 0 4 343 29 CLerpInterval::~CLerpInterval 0 0 0
36
CLerpInterval::~CLerpInterval(void);

259 23 CLerpAnimEffectInterval 0 4 345 48 CLerpAnimEffectInterval::CLerpAnimEffectInterval 0 1 93 735
// Filename: cLerpAnimEffectInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CLerpAnimEffectInterval::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
144
inline CLerpAnimEffectInterval::CLerpAnimEffectInterval(basic_string< char > const &name, double duration, CLerpInterval::BlendType blend_type);

260 11 add_control 0 4 345 36 CLerpAnimEffectInterval::add_control 0 1 94 573
////////////////////////////////////////////////////////////////////
//     Function: CLerpAnimEffectInterval::add_control
//       Access: Published
//  Description: Adds another AnimControl to the list of AnimControls
//               affected by the lerp.  This control will be lerped
//               from begin_effect to end_effect over the period of
//               the lerp.
//
//               The AnimControl name parameter is only used when
//               formatting the interval for output.
////////////////////////////////////////////////////////////////////
143
inline void CLerpAnimEffectInterval::add_control(AnimControl *control, basic_string< char > const &name, float begin_effect, float end_effect);

261 14 get_class_type 0 4 345 39 CLerpAnimEffectInterval::get_class_type 0 1 95 0
64
static TypeHandle CLerpAnimEffectInterval::get_class_type(void);

262 24 ~CLerpAnimEffectInterval 0 4 345 49 CLerpAnimEffectInterval::~CLerpAnimEffectInterval 0 0 0
56
CLerpAnimEffectInterval::~CLerpAnimEffectInterval(void);

263 21 CLerpNodePathInterval 0 4 346 44 CLerpNodePathInterval::CLerpNodePathInterval 0 1 96 1792
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::Constructor
//       Access: Published
//  Description: Constructs a lerp interval that will lerp some
//               properties on the indicated node, possibly relative
//               to the indicated other node (if other is nonempty).
//
//               You must call set_end_pos(), etc. for the various
//               properties you wish to lerp before the first call to
//               priv_initialize().  If you want to set a starting value
//               for any of the properties, you may call
//               set_start_pos(), etc.; otherwise, the starting value
//               is taken from the actual node's value at the time the
//               lerp is performed.
//
//               The starting values may be explicitly specified or
//               omitted.  The value of bake_in_start determines the
//               behavior if the starting values are omitted.  If
//               bake_in_start is true, the values are obtained the
//               first time the lerp runs, and thenceforth are stored
//               within the interval.  If bake_in_start is false, the
//               starting value is computed each frame, based on
//               assuming the current value represents the value set
//               from the last time the interval was run.  This
//               "smart" behavior allows code to manipulate the object
//               event while it is being lerped, and the lerp
//               continues to apply in a sensible way.
//
//               If fluid is true, the prev_transform is not adjusted
//               by the lerp; otherwise, it is reset.
////////////////////////////////////////////////////////////////////
210
CLerpNodePathInterval::CLerpNodePathInterval(basic_string< char > const &name, double duration, CLerpInterval::BlendType blend_type, bool bake_in_start, bool fluid, NodePath const &node, NodePath const &other);

264 8 get_node 0 4 346 31 CLerpNodePathInterval::get_node 0 1 97 758
// Filename: cLerpNodePathInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::get_node
//       Access: Published
//  Description: Returns the node being lerped.
////////////////////////////////////////////////////////////////////
67
inline NodePath const &CLerpNodePathInterval::get_node(void) const;

265 9 get_other 0 4 346 32 CLerpNodePathInterval::get_other 0 1 98 451
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::get_other
//       Access: Published
//  Description: Returns the "other" node, which the lerped node is
//               being moved relative to.  If this is an empty node
//               path, the lerped node is being moved in its own
//               coordinate system.
////////////////////////////////////////////////////////////////////
68
inline NodePath const &CLerpNodePathInterval::get_other(void) const;

266 13 set_start_pos 0 4 346 36 CLerpNodePathInterval::set_start_pos 0 1 99 547
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_pos
//       Access: Published
//  Description: Indicates the initial position of the lerped node.
//               This is meaningful only if set_end_pos() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               position at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
72
inline void CLerpNodePathInterval::set_start_pos(LVecBase3f const &pos);

267 11 set_end_pos 0 4 346 34 CLerpNodePathInterval::set_end_pos 0 1 100 531
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_pos
//       Access: Published
//  Description: Indicates that the position of the node should be
//               lerped, and specifies the final position of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's position will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
70
inline void CLerpNodePathInterval::set_end_pos(LVecBase3f const &pos);

268 13 set_start_hpr 0 4 346 36 CLerpNodePathInterval::set_start_hpr 0 1 101 589
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_hpr
//       Access: Published
//  Description: Indicates the initial rotation of the lerped node.
//               This is meaningful only if either set_end_hpr() or
//               set_end_quat() is also called.  This parameter is
//               optional; if unspecified, the value will be taken
//               from the node's actual rotation at the time the lerp
//               is performed.
////////////////////////////////////////////////////////////////////
72
inline void CLerpNodePathInterval::set_start_hpr(LVecBase3f const &hpr);

269 11 set_end_hpr 0 4 346 34 CLerpNodePathInterval::set_end_hpr 0 2 102 103 1369
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_hpr
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_quat().  If
//               neither set_end_hpr() nor set_end_quat() is called,
//               the node's rotation will not be affected by the lerp.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_hpr
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This special function is overloaded to accept a
//               quaternion, even though the function name is
//               set_end_hpr().  The quaternion will be implicitly
//               converted to a HPR trio, and the lerp will be
//               performed in HPR space, componentwise.
////////////////////////////////////////////////////////////////////
144
inline void CLerpNodePathInterval::set_end_hpr(LVecBase3f const &hpr);
inline void CLerpNodePathInterval::set_end_hpr(LQuaternionf const &quat);

270 14 set_start_quat 0 4 346 37 CLerpNodePathInterval::set_start_quat 0 1 104 590
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_quat
//       Access: Published
//  Description: Indicates the initial rotation of the lerped node.
//               This is meaningful only if either set_end_quat() or
//               set_end_hpr() is also called.  This parameter is
//               optional; if unspecified, the value will be taken
//               from the node's actual rotation at the time the lerp
//               is performed.
////////////////////////////////////////////////////////////////////
76
inline void CLerpNodePathInterval::set_start_quat(LQuaternionf const &quat);

271 12 set_end_quat 0 4 346 35 CLerpNodePathInterval::set_end_quat 0 2 105 106 1589
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_quat
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_hpr().  If
//               neither set_end_quat() nor set_end_hpr() is called,
//               the node's rotation will not be affected by the lerp.
//
//               This special function is overloaded to accept a HPR
//               trio, even though the function name is
//               set_end_quat().  The HPR will be implicitly converted
//               to a quaternion, and the lerp will be performed in
//               quaternion space, as a spherical lerp.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_quat
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_hpr().  If
//               neither set_end_quat() nor set_end_hpr() is called,
//               the node's rotation will not be affected by the lerp.
////////////////////////////////////////////////////////////////////
146
inline void CLerpNodePathInterval::set_end_quat(LVecBase3f const &hpr);
inline void CLerpNodePathInterval::set_end_quat(LQuaternionf const &quat);

272 15 set_start_scale 0 4 346 38 CLerpNodePathInterval::set_start_scale 0 2 107 108 1092
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_scale
//       Access: Published
//  Description: Indicates the initial scale of the lerped node.
//               This is meaningful only if set_end_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               scale at the time the lerp is performed.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_scale
//       Access: Published
//  Description: Indicates the initial scale of the lerped node.
//               This is meaningful only if set_end_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               scale at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
141
inline void CLerpNodePathInterval::set_start_scale(LVecBase3f const &scale);
inline void CLerpNodePathInterval::set_start_scale(float scale);

273 13 set_end_scale 0 4 346 36 CLerpNodePathInterval::set_end_scale 0 2 109 110 1050
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_scale
//       Access: Published
//  Description: Indicates that the scale of the node should be
//               lerped, and specifies the final scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's scale will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_scale
//       Access: Published
//  Description: Indicates that the scale of the node should be
//               lerped, and specifies the final scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's scale will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
137
inline void CLerpNodePathInterval::set_end_scale(LVecBase3f const &scale);
inline void CLerpNodePathInterval::set_end_scale(float scale);

274 15 set_start_shear 0 4 346 38 CLerpNodePathInterval::set_start_shear 0 1 111 545
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_shear
//       Access: Published
//  Description: Indicates the initial shear of the lerped node.
//               This is meaningful only if set_end_shear() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               shear at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
76
inline void CLerpNodePathInterval::set_start_shear(LVecBase3f const &shear);

275 13 set_end_shear 0 4 346 36 CLerpNodePathInterval::set_end_shear 0 1 112 524
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_shear
//       Access: Published
//  Description: Indicates that the shear of the node should be
//               lerped, and specifies the final shear of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's shear will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
74
inline void CLerpNodePathInterval::set_end_shear(LVecBase3f const &shear);

276 15 set_start_color 0 4 346 38 CLerpNodePathInterval::set_start_color 0 1 113 545
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_color
//       Access: Published
//  Description: Indicates the initial color of the lerped node.
//               This is meaningful only if set_end_color() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               color at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
76
inline void CLerpNodePathInterval::set_start_color(LVecBase4f const &color);

277 13 set_end_color 0 4 346 36 CLerpNodePathInterval::set_end_color 0 1 114 524
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_color
//       Access: Published
//  Description: Indicates that the color of the node should be
//               lerped, and specifies the final color of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's color will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
74
inline void CLerpNodePathInterval::set_end_color(LVecBase4f const &color);

278 21 set_start_color_scale 0 4 346 44 CLerpNodePathInterval::set_start_color_scale 0 1 115 569
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_color_scale
//       Access: Published
//  Description: Indicates the initial color scale of the lerped node.
//               This is meaningful only if set_end_color_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               color scale at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
88
inline void CLerpNodePathInterval::set_start_color_scale(LVecBase4f const &color_scale);

279 19 set_end_color_scale 0 4 346 42 CLerpNodePathInterval::set_end_color_scale 0 1 116 548
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_color_scale
//       Access: Published
//  Description: Indicates that the color scale of the node should be
//               lerped, and specifies the final color scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's color scale will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
86
inline void CLerpNodePathInterval::set_end_color_scale(LVecBase4f const &color_scale);

280 17 set_texture_stage 0 4 346 40 CLerpNodePathInterval::set_texture_stage 0 1 117 426
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_texture_stage
//       Access: Published
//  Description: Indicates the texture stage that is adjusted by
//               tex_offset, tex_rotate, and/or tex_scale.  If this is
//               not set, the default is the default texture stage.
////////////////////////////////////////////////////////////////////
74
inline void CLerpNodePathInterval::set_texture_stage(TextureStage *stage);

281 20 set_start_tex_offset 0 4 346 43 CLerpNodePathInterval::set_start_tex_offset 0 1 118 563
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_tex_offset
//       Access: Published
//  Description: Indicates the initial UV offset of the lerped node.
//               This is meaningful only if set_end_tex_offset() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               UV offset at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
86
inline void CLerpNodePathInterval::set_start_tex_offset(LVecBase2f const &tex_offset);

282 18 set_end_tex_offset 0 4 346 41 CLerpNodePathInterval::set_end_tex_offset 0 1 119 541
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_tex_offset
//       Access: Published
//  Description: Indicates that the UV offset of the node should be
//               lerped, and specifies the final UV offset of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's UV offset will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
84
inline void CLerpNodePathInterval::set_end_tex_offset(LVecBase2f const &tex_offset);

283 20 set_start_tex_rotate 0 4 346 43 CLerpNodePathInterval::set_start_tex_rotate 0 1 120 563
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_tex_rotate
//       Access: Published
//  Description: Indicates the initial UV rotate of the lerped node.
//               This is meaningful only if set_end_tex_rotate() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               UV rotate at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
74
inline void CLerpNodePathInterval::set_start_tex_rotate(float tex_rotate);

284 18 set_end_tex_rotate 0 4 346 41 CLerpNodePathInterval::set_end_tex_rotate 0 1 121 541
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_tex_rotate
//       Access: Published
//  Description: Indicates that the UV rotate of the node should be
//               lerped, and specifies the final UV rotate of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's UV rotate will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
72
inline void CLerpNodePathInterval::set_end_tex_rotate(float tex_rotate);

285 19 set_start_tex_scale 0 4 346 42 CLerpNodePathInterval::set_start_tex_scale 0 1 122 559
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_tex_scale
//       Access: Published
//  Description: Indicates the initial UV scale of the lerped node.
//               This is meaningful only if set_end_tex_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               UV scale at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
84
inline void CLerpNodePathInterval::set_start_tex_scale(LVecBase2f const &tex_scale);

286 17 set_end_tex_scale 0 4 346 40 CLerpNodePathInterval::set_end_tex_scale 0 1 123 537
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_tex_scale
//       Access: Published
//  Description: Indicates that the UV scale of the node should be
//               lerped, and specifies the final UV scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's UV scale will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
82
inline void CLerpNodePathInterval::set_end_tex_scale(LVecBase2f const &tex_scale);

287 12 set_override 0 4 346 35 CLerpNodePathInterval::set_override 0 1 124 623
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_override
//       Access: Published
//  Description: Changes the override value that will be associated
//               with any state changes applied by the lerp.  If this
//               lerp is changing state (for instance, a color lerp or
//               a tex matrix lerp), then the new attributes created
//               by this lerp will be assigned the indicated override
//               value when they are applied to the node.
////////////////////////////////////////////////////////////////////
62
inline void CLerpNodePathInterval::set_override(int override);

288 12 get_override 0 4 346 35 CLerpNodePathInterval::get_override 0 1 125 384
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::get_override
//       Access: Published
//  Description: Returns the override value that will be associated
//               with any state changes applied by the lerp.  See
//               set_override().
////////////////////////////////////////////////////////////////////
59
inline int CLerpNodePathInterval::get_override(void) const;

289 14 get_class_type 0 4 346 37 CLerpNodePathInterval::get_class_type 0 1 126 0
62
static TypeHandle CLerpNodePathInterval::get_class_type(void);

290 22 ~CLerpNodePathInterval 0 4 346 45 CLerpNodePathInterval::~CLerpNodePathInterval 0 0 0
52
CLerpNodePathInterval::~CLerpNodePathInterval(void);

291 13 CMetaInterval 0 4 347 28 CMetaInterval::CMetaInterval 0 1 127 226
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
63
CMetaInterval::CMetaInterval(basic_string< char > const &name);

292 13 set_precision 0 4 347 28 CMetaInterval::set_precision 0 1 128 1201
// Filename: cMetaInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::set_precision
//       Access: Published
//  Description: Indicates the precision with which time measurements
//               are compared.  For numerical accuracy, all
//               floating-point time values are converted to integer
//               values internally by scaling by the precision factor.
//               The larger the number given here, the smaller the
//               delta of time that can be differentiated; the
//               limit is the maximum integer that can be represented
//               in the system.
////////////////////////////////////////////////////////////////////
59
inline void CMetaInterval::set_precision(double precision);

293 13 get_precision 0 4 347 28 CMetaInterval::get_precision 0 1 129 331
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_precision
//       Access: Published
//  Description: Returns the precision with which time measurements
//               are compared.  See set_precision().
////////////////////////////////////////////////////////////////////
55
inline double CMetaInterval::get_precision(void) const;

294 15 clear_intervals 0 4 347 30 CMetaInterval::clear_intervals 0 1 130 314
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::clear_intervals
//       Access: Published
//  Description: Resets the list of intervals and prepares for
//               receiving a new list.
////////////////////////////////////////////////////////////////////
42
void CMetaInterval::clear_intervals(void);

295 10 push_level 0 4 347 25 CMetaInterval::push_level 0 1 131 647
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::push_level
//       Access: Published
//  Description: Marks the beginning of a nested level of child
//               intervals.  Within the nested level, a RelativeStart
//               time of RS_level_begin refers to the start of the
//               level, and the first interval added within the level
//               is always relative to the start of the level.
//
//               The return value is the index of the def entry
//               created by this push.
////////////////////////////////////////////////////////////////////
118
int CMetaInterval::push_level(basic_string< char > const &name, double rel_time, CMetaInterval::RelativeStart rel_to);

296 14 add_c_interval 0 4 347 29 CMetaInterval::add_c_interval 0 3 132 133 134 512
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::add_c_interval
//       Access: Published
//  Description: Adds a new CInterval to the list.  The interval will
//               be played when the indicated time (relative to the
//               given point) has been reached.
//
//               The return value is the index of the def entry
//               representing the new interval.
////////////////////////////////////////////////////////////////////
137
int CMetaInterval::add_c_interval(CInterval *c_interval, double rel_time = (0), CMetaInterval::RelativeStart rel_to = (RS_previous_end));

297 13 add_ext_index 0 4 347 28 CMetaInterval::add_ext_index 0 1 135 1156
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::add_ext_index
//       Access: Published
//  Description: Adds a new external interval to the list.  This
//               represents some object in the external scripting
//               language that has properties similar to a CInterval
//               (for instance, a Python Interval object).
//
//               The CMetaInterval object cannot play this external
//               interval directly, but it records a placeholder for
//               it and will ask the scripting language to play it
//               when it is time, via is_event_ready() and related
//               methods.
//
//               The ext_index number itself is simply a handle that
//               the scripting language makes up and associates with
//               its interval object somehow.  The CMetaInterval
//               object does not attempt to interpret this value.
//
//               The return value is the index of the def entry
//               representing the new interval.
////////////////////////////////////////////////////////////////////
170
int CMetaInterval::add_ext_index(int ext_index, basic_string< char > const &name, double duration, bool open_ended, double rel_time, CMetaInterval::RelativeStart rel_to);

298 9 pop_level 0 4 347 24 CMetaInterval::pop_level 0 2 136 137 645
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::pop_level
//       Access: Published
//  Description: Finishes a level marked by a previous call to
//               push_level(), and returns to the previous level.
//
//               If the duration is not negative, it represents a
//               phony duration to assign to the level, for the
//               purposes of sequencing later intervals.  Otherwise,
//               the level's duration is computed based on the
//               intervals within the level.
////////////////////////////////////////////////////////////////////
53
int CMetaInterval::pop_level(double duration = (-1));

299 23 set_interval_start_time 0 4 347 38 CMetaInterval::set_interval_start_time 0 2 138 139 824
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::set_interval_start_time
//       Access: Published
//  Description: Adjusts the start time of the child interval with the
//               given name, if found.  This may be either a C++
//               interval added via add_c_interval(), or an external
//               interval added via add_ext_index(); the name must
//               match exactly.
//
//               If the interval is found, its start time is adjusted,
//               and all subsequent intervals are adjusting
//               accordingly, and true is returned.  If a matching
//               interval is not found, nothing is changed and false
//               is returned.
////////////////////////////////////////////////////////////////////
151
bool CMetaInterval::set_interval_start_time(basic_string< char > const &name, double rel_time, CMetaInterval::RelativeStart rel_to = (RS_level_begin));

300 23 get_interval_start_time 0 4 347 38 CMetaInterval::get_interval_start_time 0 1 140 451
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_interval_start_time
//       Access: Published
//  Description: Returns the actual start time, relative to the
//               beginning of the interval, of the child interval with
//               the given name, if found, or -1 if the interval is
//               not found.
////////////////////////////////////////////////////////////////////
86
double CMetaInterval::get_interval_start_time(basic_string< char > const &name) const;

301 21 get_interval_end_time 0 4 347 36 CMetaInterval::get_interval_end_time 0 1 141 447
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_interval_end_time
//       Access: Published
//  Description: Returns the actual end time, relative to the
//               beginning of the interval, of the child interval with
//               the given name, if found, or -1 if the interval is
//               not found.
////////////////////////////////////////////////////////////////////
84
double CMetaInterval::get_interval_end_time(basic_string< char > const &name) const;

302 12 get_num_defs 0 4 347 27 CMetaInterval::get_num_defs 0 1 142 359
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_num_defs
//       Access: Published
//  Description: Returns the number of interval and push/pop
//               definitions that have been added to the meta
//               interval.
////////////////////////////////////////////////////////////////////
51
inline int CMetaInterval::get_num_defs(void) const;

303 12 get_def_type 0 4 347 27 CMetaInterval::get_def_type 0 1 143 312
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_def_type
//       Access: Published
//  Description: Returns the type of the nth interval definition that
//               has been added.
////////////////////////////////////////////////////////////////////
71
inline CMetaInterval::DefType CMetaInterval::get_def_type(int n) const;

304 14 get_c_interval 0 4 347 29 CMetaInterval::get_c_interval 0 1 144 409
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_c_interval
//       Access: Published
//  Description: Return the CInterval pointer associated with the nth
//               interval definition.  It is only valid to call this
//               if get_def_type(n) returns DT_c_interval.
////////////////////////////////////////////////////////////////////
61
inline CInterval *CMetaInterval::get_c_interval(int n) const;

305 13 get_ext_index 0 4 347 28 CMetaInterval::get_ext_index 0 1 145 420
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_ext_index
//       Access: Published
//  Description: Return the external interval index number associated
//               with the nth interval definition.  It is only valid
//               to call this if get_def_type(n) returns DT_ext_index.
////////////////////////////////////////////////////////////////////
53
inline int CMetaInterval::get_ext_index(int n) const;

306 14 is_event_ready 0 4 347 29 CMetaInterval::is_event_ready 0 1 146 544
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::is_event_ready
//       Access: Published
//  Description: Returns true if a recent call to priv_initialize(),
//               priv_step(), or priv_finalize() has left some external
//               intervals ready to play.  If this returns true, call
//               get_event_index(), get_event_t(), and pop_event() to
//               retrieve the relevant information.
////////////////////////////////////////////////////////////////////
48
inline bool CMetaInterval::is_event_ready(void);

307 15 get_event_index 0 4 347 30 CMetaInterval::get_event_index 0 1 147 444
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_index
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the index number (added via
//               add_event_index()) of the external interval that needs
//               to be played.
////////////////////////////////////////////////////////////////////
54
inline int CMetaInterval::get_event_index(void) const;

308 11 get_event_t 0 4 347 26 CMetaInterval::get_event_t 0 1 148 380
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_t
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the t value that should be fed to
//               the given interval.
////////////////////////////////////////////////////////////////////
53
inline double CMetaInterval::get_event_t(void) const;

309 14 get_event_type 0 4 347 29 CMetaInterval::get_event_type 0 1 149 410
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_type
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the type of the event (initialize,
//               step, finalize, etc.) for the given interval.
////////////////////////////////////////////////////////////////////
70
inline CInterval::EventType CMetaInterval::get_event_type(void) const;

310 9 pop_event 0 4 347 24 CMetaInterval::pop_event 0 1 150 591
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::pop_event
//       Access: Published
//  Description: Acknowledges that the external interval on the top of
//               the queue has been extracted, and is about to be
//               serviced by the scripting language.  This prepares
//               the interval so the next call to is_event_ready()
//               will return information about the next external
//               interval on the queue, if any.
////////////////////////////////////////////////////////////////////
36
void CMetaInterval::pop_event(void);

311 8 timeline 0 4 347 23 CMetaInterval::timeline 0 1 151 302
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::timeline
//       Access: Published
//  Description: Outputs a list of all events in the order in which
//               they occur.
////////////////////////////////////////////////////////////////////
49
void CMetaInterval::timeline(ostream &out) const;

312 14 get_class_type 0 4 347 29 CMetaInterval::get_class_type 0 1 152 0
54
static TypeHandle CMetaInterval::get_class_type(void);

313 12 HideInterval 0 4 350 26 HideInterval::HideInterval 0 2 153 154 225
////////////////////////////////////////////////////////////////////
//     Function: HideInterval::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
98
HideInterval::HideInterval(NodePath const &node, basic_string< char > const &name = ((string())));

314 14 get_class_type 0 4 350 28 HideInterval::get_class_type 0 1 155 0
53
static TypeHandle HideInterval::get_class_type(void);

315 13 ~HideInterval 0 4 350 27 HideInterval::~HideInterval 0 0 0
34
HideInterval::~HideInterval(void);

316 11 operator () 0 4 351 26 LerpBlendType::operator () 0 1 156 0
53
virtual float LerpBlendType::operator ()(float ) = 0;

317 14 get_class_type 0 4 351 29 LerpBlendType::get_class_type 0 1 157 27
// now for typehandle stuff
54
static TypeHandle LerpBlendType::get_class_type(void);

318 15 EaseInBlendType 0 4 352 32 EaseInBlendType::EaseInBlendType 0 1 158 0
39
EaseInBlendType::EaseInBlendType(void);

319 14 get_class_type 0 4 352 31 EaseInBlendType::get_class_type 0 1 159 27
// now for typehandle stuff
56
static TypeHandle EaseInBlendType::get_class_type(void);

320 16 EaseOutBlendType 0 4 353 34 EaseOutBlendType::EaseOutBlendType 0 1 160 0
41
EaseOutBlendType::EaseOutBlendType(void);

321 14 get_class_type 0 4 353 32 EaseOutBlendType::get_class_type 0 1 161 27
// now for typehandle stuff
57
static TypeHandle EaseOutBlendType::get_class_type(void);

322 18 EaseInOutBlendType 0 4 354 38 EaseInOutBlendType::EaseInOutBlendType 0 1 162 0
45
EaseInOutBlendType::EaseInOutBlendType(void);

323 14 get_class_type 0 4 354 34 EaseInOutBlendType::get_class_type 0 1 163 27
// now for typehandle stuff
59
static TypeHandle EaseInOutBlendType::get_class_type(void);

324 11 NoBlendType 0 4 355 24 NoBlendType::NoBlendType 0 1 164 0
31
NoBlendType::NoBlendType(void);

325 14 get_class_type 0 4 355 27 NoBlendType::get_class_type 0 1 165 27
// now for typehandle stuff
52
static TypeHandle NoBlendType::get_class_type(void);

326 12 ShowInterval 0 4 356 26 ShowInterval::ShowInterval 0 2 166 167 225
////////////////////////////////////////////////////////////////////
//     Function: ShowInterval::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
98
ShowInterval::ShowInterval(NodePath const &node, basic_string< char > const &name = ((string())));

327 14 get_class_type 0 4 356 28 ShowInterval::get_class_type 0 1 168 0
53
static TypeHandle ShowInterval::get_class_type(void);

328 13 ~ShowInterval 0 4 356 27 ShowInterval::~ShowInterval 0 0 0
34
ShowInterval::~ShowInterval(void);

329 12 WaitInterval 0 4 357 26 WaitInterval::WaitInterval 0 1 169 827
// Filename: waitInterval.I
// Created by:  drose (12Sep02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: WaitInterval::Constructor
//       Access: Published
//  Description: All Wait intervals have the same name.  No one really
//               cares if their names are unique, after all.
////////////////////////////////////////////////////////////////////
51
inline WaitInterval::WaitInterval(double duration);

330 14 get_class_type 0 4 357 28 WaitInterval::get_class_type 0 1 170 0
53
static TypeHandle WaitInterval::get_class_type(void);

331 13 ~WaitInterval 0 4 357 27 WaitInterval::~WaitInterval 0 0 0
34
WaitInterval::~WaitInterval(void);

170
1 14 Dtool_ceEZfV5F 0 6 3 360 0 14 Dtool_ceEZfV5F 732 // Filename: cInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_name
//       Access: Published
//  Description: Returns the interval's name.
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
2 14 Dtool_ceEZ8svE 0 6 4 361 0 14 Dtool_ceEZ8svE 271 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_duration
//       Access: Published
//  Description: Returns the duration of the interval in seconds.
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
3 14 Dtool_ceEZB6uv 0 6 5 337 0 14 Dtool_ceEZB6uv 685 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_open_ended
//       Access: Published
//  Description: Returns the state of the "open_ended" flag.  This is
//               primarily intended for instantaneous intervals like
//               FunctionIntervals; it indicates true if the interval
//               has some lasting effect that should be applied even
//               if the interval doesn't get started until after its
//               finish time, or false if the interval is a transitive
//               thing that doesn't need to be called late.
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
4 14 Dtool_ceEZvfjT 0 6 8 335 0 14 Dtool_ceEZvfjT 385 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_state
//       Access: Published
//  Description: Indicates the state the interval believes it is in:
//               whether it has been started, is currently in the
//               middle, or has been finalized.
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
5 14 Dtool_ceEZs6CA 0 6 9 337 0 14 Dtool_ceEZs6CA 364 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::is_stopped
//       Access: Published
//  Description: Returns true if the interval is in either its initial
//               or final states (but not in a running or paused
//               state).
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
6 14 Dtool_ceEZso5p 0 4 10 363 0 14 Dtool_ceEZso5p 426 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_done_event
//       Access: Published
//  Description: Sets the event that is generated whenever the
//               interval reaches its final state, whether it is
//               explicitly finished or whether it gets there on its
//               own.
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  5 event 1 360  
7 14 Dtool_ceEZU1_s 0 6 11 360 0 14 Dtool_ceEZU1_s 429 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_done_event
//       Access: Published
//  Description: Returns the event that is generated whenever the
//               interval reaches its final state, whether it is
//               explicitly finished or whether it gets there on its
//               own.
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
8 14 Dtool_ceEZnHap 0 4 12 363 0 14 Dtool_ceEZnHap 450 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_t
//       Access: Published
//  Description: Explicitly sets the time within the interval.
//               Normally, you would use start() .. finish() to let
//               the time play normally, but this may be used to set
//               the time to some particular value.
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  1 t 1 361  
9 14 Dtool_ceEZEMrp 0 6 13 361 0 14 Dtool_ceEZEMrp 373 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_t
//       Access: Published
//  Description: Returns the current time of the interval: the last
//               value of t passed to priv_initialize(), priv_step(), or
//               priv_finalize().
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
10 14 Dtool_ceEZK6Bt 0 4 14 363 0 14 Dtool_ceEZK6Bt 624 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_auto_pause
//       Access: Published
//  Description: Changes the state of the 'auto_pause' flag.  If
//               this is true, the interval may be arbitrarily
//               interrupted when the system needs to reset due to
//               some external event by calling
//               CIntervalManager::interrupt().  If this
//               is false (the default), the interval must always be
//               explicitly finished or paused.
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  10 auto_pause 1 337  
11 14 Dtool_ceEZLOK8 0 6 15 337 0 14 Dtool_ceEZLOK8 308 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_auto_pause
//       Access: Published
//  Description: Returns the state of the 'auto_pause' flag.  See
//               set_auto_pause().
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
12 14 Dtool_ceEZwEgz 0 4 16 363 0 14 Dtool_ceEZwEgz 623 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_auto_finish
//       Access: Published
//  Description: Changes the state of the 'auto_finish' flag.  If
//               this is true, the interval may be arbitrarily
//               finished when the system needs to reset due to
//               some external event by calling
//               CIntervalManager::interrupt().  If this
//               is false (the default), the interval must always be
//               explicitly finished or paused.
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  11 auto_finish 1 337  
13 14 Dtool_ceEZK3xj 0 6 17 337 0 14 Dtool_ceEZK3xj 311 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_auto_finish
//       Access: Published
//  Description: Returns the state of the 'auto_finish' flag.  See
//               set_auto_finish().
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
14 14 Dtool_ceEZU4Wd 0 4 18 363 0 14 Dtool_ceEZU4Wd 533 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_wants_t_callback
//       Access: Published
//  Description: Changes the state of the 'wants_t_callback' flag.  If
//               this is true, the interval will be returned by
//               CIntervalManager::get_event() each time the
//               interval's time value has been changed, regardless of
//               whether it has any external events.
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  16 wants_t_callback 1 337  
15 14 Dtool_ceEZzuIb 0 6 19 337 0 14 Dtool_ceEZzuIb 325 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_wants_t_callback
//       Access: Published
//  Description: Returns the state of the 'wants_t_callback' flag.
//               See set_wants_t_callback().
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
16 14 Dtool_ceEZVrzY 0 4 20 363 0 14 Dtool_ceEZVrzY 523 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_manager
//       Access: Published
//  Description: Indicates the CIntervalManager object which will be
//               responsible for playing this interval.  This defaults
//               to the global CIntervalManager; you should need to
//               change this only if you have special requirements for
//               playing this interval.
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  7 manager 1 364  
17 14 Dtool_ceEZzijv 0 6 21 364 0 14 Dtool_ceEZzijv 604 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_manager
//       Access: Published
//  Description: Returns the CIntervalManager object which will be
//               responsible for playing this interval.  Note that
//               this can only return a C++ object; if the particular
//               CIntervalManager object has been extended in the
//               scripting language, this will return the encapsulated
//               C++ object, not the full extended object.
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
18 14 Dtool_ceEZOA1D 0 4 22 363 0 14 Dtool_ceEZOA1D 478 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::start
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play to the end and stop.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 4 4 this 3 362  7 start_t 1 361  5 end_t 1 361  9 play_rate 1 361  
19 14 Dtool_ceEZsz84 0 4 22 363 0 14 Dtool_ceEZsz84 478 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::start
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play to the end and stop.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 3 4 this 3 362  7 start_t 1 361  5 end_t 1 361  
20 14 Dtool_ceEZV_pK 0 4 22 363 0 14 Dtool_ceEZV_pK 478 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::start
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play to the end and stop.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  7 start_t 1 361  
21 14 Dtool_ceEZI9Ch 0 4 22 363 0 14 Dtool_ceEZI9Ch 478 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::start
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play to the end and stop.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 1 4 this 3 362  
22 14 Dtool_ceEZlvuV 0 4 23 363 0 14 Dtool_ceEZlvuV 587 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::loop
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play until it is interrupted with finish() or
//               pause(), looping back to start_t when it reaches
//               end_t.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 4 4 this 3 362  7 start_t 1 361  5 end_t 1 361  9 play_rate 1 361  
23 14 Dtool_ceEZN0b7 0 4 23 363 0 14 Dtool_ceEZN0b7 587 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::loop
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play until it is interrupted with finish() or
//               pause(), looping back to start_t when it reaches
//               end_t.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 3 4 this 3 362  7 start_t 1 361  5 end_t 1 361  
24 14 Dtool_ceEZDdAk 0 4 23 363 0 14 Dtool_ceEZDdAk 587 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::loop
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play until it is interrupted with finish() or
//               pause(), looping back to start_t when it reaches
//               end_t.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  7 start_t 1 361  
25 14 Dtool_ceEZdHuO 0 4 23 363 0 14 Dtool_ceEZdHuO 587 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::loop
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play until it is interrupted with finish() or
//               pause(), looping back to start_t when it reaches
//               end_t.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 1 4 this 3 362  
26 14 Dtool_ceEZYZXB 0 6 24 361 0 14 Dtool_ceEZYZXB 379 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::pause
//       Access: Published
//  Description: Stops the interval from playing but leaves it in its
//               current state.  It may later be resumed from this
//               point by calling resume().
//////////////////////////////////////////////////////////////////// 1 4 this 3 362  
27 14 Dtool_ceEZOoeF 0 4 25 363 0 14 Dtool_ceEZOoeF 312 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume
//       Access: Published
//  Description: Restarts the interval from its current point after a
//               previous call to pause().
//////////////////////////////////////////////////////////////////// 1 4 this 3 362  
28 14 Dtool_ceEZC2L6 0 4 25 363 0 14 Dtool_ceEZC2L6 314 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume
//       Access: Published
//  Description: Restarts the interval from the indicated point after a
//               previous call to pause().
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  7 start_t 1 361  
29 14 Dtool_ceEZYMh8 0 4 26 363 0 14 Dtool_ceEZYMh8 440 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume_until
//       Access: Published
//  Description: Restarts the interval from the current point after a
//               previous call to pause() (or a previous
//               play-to-point-and-stop), to play until the indicated
//               point and then stop.
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  5 end_t 1 361  
30 14 Dtool_ceEZIWoe 0 4 27 363 0 14 Dtool_ceEZIWoe 297 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::finish
//       Access: Published
//  Description: Stops the interval from playing and sets it to its
//               final state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 362  
31 14 Dtool_ceEZ9awK 0 4 28 363 0 14 Dtool_ceEZ9awK 551 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::clear_to_initial
//       Access: Published
//  Description: Pauses the interval, if it is playing, and resets its
//               state to its initial state, abandoning any state
//               changes already in progress in the middle of the
//               interval.  Calling this is like pausing the interval
//               and discarding it, creating a new one in its place.
//////////////////////////////////////////////////////////////////// 1 4 this 3 362  
32 14 Dtool_ceEZLlcY 0 6 29 337 0 14 Dtool_ceEZLlcY 305 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::is_playing
//       Access: Published
//  Description: Returns true if the interval is currently playing,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
33 14 Dtool_ceEZh9_Q 0 6 30 361 0 14 Dtool_ceEZh9_Q 326 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_play_rate
//       Access: Published
//  Description: Returns the play rate as set by the last call to
//               start(), loop(), or set_play_rate().
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
34 14 Dtool_ceEZhAaa 0 4 31 363 0 14 Dtool_ceEZhAaa 529 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_play_rate
//       Access: Published
//  Description: Changes the play rate of the interval.  If the
//               interval is already started, this changes its speed
//               on-the-fly.  Note that since play_rate is a parameter
//               to start() and loop(), the next call to start() or
//               loop() will reset this parameter.
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  9 play_rate 1 361  
35 14 Dtool_ceEZsrd8 0 4 32 363 0 14 Dtool_ceEZsrd8 402 // These functions control the actual playback of the interval.
// Don't call them directly; they're intended to be called from a
// supervising object, e.g. the Python start() .. finish()
// interface.
// These cannot be declared private because they must be accessible
// to Python, but the method names are prefixed with priv_ to remind
// you that you probably don't want to be using them directly. 3 4 this 3 362  1 t 1 361  5 event 1 334  
36 14 Dtool_ceEZADw2 0 4 33 363 0 14 Dtool_ceEZADw2 485 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_initialize
//       Access: Published, Virtual
//  Description: This replaces the first call to priv_step(), and indicates
//               that the interval has just begun.  This may be
//               overridden by derived classes that need to do some
//               explicit initialization on the first call.
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  1 t 1 361  
37 14 Dtool_ceEZ_B_n 0 4 34 363 0 14 Dtool_ceEZ_B_n 486 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_instant
//       Access: Published, Virtual
//  Description: This is called in lieu of priv_initialize() .. priv_step()
//               .. priv_finalize(), when everything is to happen within
//               one frame.  The interval should initialize itself,
//               then leave itself in the final state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 362  
38 14 Dtool_ceEZU3CU 0 4 35 363 0 14 Dtool_ceEZU3CU 409 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_step
//       Access: Published, Virtual
//  Description: Advances the time on the interval.  The time may
//               either increase (the normal case) or decrease
//               (e.g. if the interval is being played by a slider).
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  1 t 1 361  
39 14 Dtool_ceEZcdRd 0 4 36 363 0 14 Dtool_ceEZcdRd 439 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_finalize
//       Access: Published, Virtual
//  Description: This is called to stop an interval, forcing it to
//               whatever state it would be after it played all the
//               way through.  It's generally invoked by
//               set_final_t().
//////////////////////////////////////////////////////////////////// 1 4 this 3 362  
40 14 Dtool_ceEZzQVo 0 4 37 363 0 14 Dtool_ceEZzQVo 485 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_initialize
//       Access: Published, Virtual
//  Description: Similar to priv_initialize(), but this is called when the
//               interval is being played backwards; it indicates that
//               the interval should start at the finishing state and
//               undo any intervening intervals.
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  1 t 1 361  
41 14 Dtool_ceEZyAlT 0 4 38 363 0 14 Dtool_ceEZyAlT 524 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_instant
//       Access: Published, Virtual
//  Description: This is called in lieu of priv_reverse_initialize()
//               .. priv_step() .. priv_reverse_finalize(), when everything is
//               to happen within one frame.  The interval should
//               initialize itself, then leave itself in the initial
//               state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 362  
42 14 Dtool_ceEZtoBu 0 4 39 363 0 14 Dtool_ceEZtoBu 393 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_finalize
//       Access: Published, Virtual
//  Description: Called generally following a priv_reverse_initialize(),
//               this indicates the interval should set itself to the
//               initial state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 362  
43 14 Dtool_ceEZpKBe 0 4 40 363 0 14 Dtool_ceEZpKBe 812 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_interrupt
//       Access: Published, Virtual
//  Description: This is called while the interval is playing to
//               indicate that it is about to be interrupted; that is,
//               priv_step() will not be called for a length of time.  But
//               the interval should remain in its current state in
//               anticipation of being eventually restarted when the
//               calls to priv_step() eventually resume.
//
//               The purpose of this function is to allow self-running
//               intervals like sound intervals to stop the actual
//               sound playback during the pause.
//////////////////////////////////////////////////////////////////// 1 4 this 3 362  
44 14 Dtool_ceEZ6w_D 0 4 41 363 0 14 Dtool_ceEZ6w_D 226 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::output
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 358  3 out 1 365  
45 14 Dtool_ceEZLeD7 0 4 42 363 0 14 Dtool_ceEZLeD7 225 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::write
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 358  3 out 1 365  12 indent_level 1 367  
46 14 Dtool_ceEZzgQa 0 4 43 363 0 14 Dtool_ceEZzgQa 831 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_play
//       Access: Published
//  Description: Called to prepare the interval for automatic timed
//               playback, e.g. via a Python task.  The interval will
//               be played from start_t to end_t, at a time factor
//               specified by play_rate.  start_t must always be less
//               than end_t (except for the exception for end_t == -1,
//               below), but if play_rate is negative the interval
//               will be played backwards.
//
//               Specify end_t of -1 to play the entire interval from
//               start_t.
//
//               Call step_play() repeatedly to execute the interval.
//////////////////////////////////////////////////////////////////// 5 4 this 3 362  10 start_time 1 361  8 end_time 1 361  9 play_rate 1 361  7 do_loop 1 337  
47 14 Dtool_ceEZUryc 0 4 44 363 0 14 Dtool_ceEZUryc 366 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_resume
//       Access: Published
//  Description: Called to prepare the interval for restarting at the
//               current point within the interval after an
//               interruption.
//////////////////////////////////////////////////////////////////// 1 4 this 3 362  
48 14 Dtool_ceEZscch 0 4 45 363 0 14 Dtool_ceEZscch 470 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_resume_until
//       Access: Published
//  Description: Called to prepare the interval for restarting from
//               the current point after a previous call to pause()
//               (or a previous play-to-point-and-stop), to play until
//               the indicated point and then stop.
//////////////////////////////////////////////////////////////////// 2 4 this 3 362  5 end_t 1 361  
49 14 Dtool_ceEZNGqy 0 6 46 337 0 14 Dtool_ceEZNGqy 453 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::step_play
//       Access: Published
//  Description: Should be called once per frame to execute the
//               automatic timed playback begun with setup_play().
//
//               Returns true if the interval should continue, false
//               if it is done and should stop.
//////////////////////////////////////////////////////////////////// 1 4 this 3 362  
50 14 Dtool_ceEZStxv 0 7 47 369 0 14 Dtool_ceEZStxv 0 0 
51 14 Dtool_ceEZ3rB9 0 7 53 369 0 14 Dtool_ceEZ3rB9 0 0 
52 14 Dtool_ceEZ6b9E 0 6 50 337 0 14 Dtool_ceEZ6b9E 0 1 4 this 3 370  
53 14 Dtool_ceEZnsBv 0 4 51 363 0 14 Dtool_ceEZnsBv 0 2 4 this 3 372  5 value 1 337  
54 14 Dtool_ceEZjm3B 0 7 56 379 222 14 Dtool_ceEZjm3B 682 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainHprInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the orientation of one node to the orientation of
//               another, possibly with an added rotation.
//
//               If wrt is true, the node's orientation will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the target
//               node's local orientation will be copied unaltered.
//////////////////////////////////////////////////////////////////// 6 4 name 1 360  8 duration 1 361  4 node 1 373  6 target 1 373  3 wrt 1 337  9 hprOffset 1 376  
55 14 Dtool_ceEZJRAe 0 7 56 379 222 14 Dtool_ceEZJRAe 682 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainHprInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the orientation of one node to the orientation of
//               another, possibly with an added rotation.
//
//               If wrt is true, the node's orientation will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the target
//               node's local orientation will be copied unaltered.
//////////////////////////////////////////////////////////////////// 5 4 name 1 360  8 duration 1 361  4 node 1 373  6 target 1 373  3 wrt 1 337  
56 14 Dtool_ceEZG_dN 0 6 57 373 0 14 Dtool_ceEZG_dN 754 // Filename: cConstrainHprInterval.I
// Created by:  pratt (10Mar08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainHprInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 380  
57 14 Dtool_ceEZptoY 0 6 58 373 0 14 Dtool_ceEZptoY 259 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainHprInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 380  
58 14 Dtool_ceEZka3O 0 7 59 369 0 14 Dtool_ceEZka3O 0 0 
59 14 Dtool_ceEZpdjK 0 7 62 382 227 14 Dtool_ceEZpdjK 720 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the position and orientation of one node to the
//               position and orientation of another.
//
//               If wrt is true, the node's position and orientation
//               will be transformed into the target node's parent's
//               space before being copied.  If wrt is false, the
//               target node's local position and orientation will be
//               copied unaltered.
//////////////////////////////////////////////////////////////////// 7 4 name 1 360  8 duration 1 361  4 node 1 373  6 target 1 373  3 wrt 1 337  9 posOffset 1 376  9 hprOffset 1 376  
60 14 Dtool_ceEZMtsm 0 7 62 382 227 14 Dtool_ceEZMtsm 720 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the position and orientation of one node to the
//               position and orientation of another.
//
//               If wrt is true, the node's position and orientation
//               will be transformed into the target node's parent's
//               space before being copied.  If wrt is false, the
//               target node's local position and orientation will be
//               copied unaltered.
//////////////////////////////////////////////////////////////////// 6 4 name 1 360  8 duration 1 361  4 node 1 373  6 target 1 373  3 wrt 1 337  9 posOffset 1 376  
61 14 Dtool_ceEZC34s 0 7 62 382 227 14 Dtool_ceEZC34s 720 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the position and orientation of one node to the
//               position and orientation of another.
//
//               If wrt is true, the node's position and orientation
//               will be transformed into the target node's parent's
//               space before being copied.  If wrt is false, the
//               target node's local position and orientation will be
//               copied unaltered.
//////////////////////////////////////////////////////////////////// 5 4 name 1 360  8 duration 1 361  4 node 1 373  6 target 1 373  3 wrt 1 337  
62 14 Dtool_ceEZV1_L 0 6 63 373 0 14 Dtool_ceEZV1_L 760 // Filename: cConstrainPosHprInterval.I
// Created by:  pratt (10Mar08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 383  
63 14 Dtool_ceEZJY4x 0 6 64 373 0 14 Dtool_ceEZJY4x 262 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 383  
64 14 Dtool_ceEZMQBo 0 7 65 369 0 14 Dtool_ceEZMQBo 0 0 
65 14 Dtool_ceEZ3PgQ 0 7 68 385 232 14 Dtool_ceEZ3PgQ 620 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the position of one node to the position of another.
//
//               If wrt is true, the node's position will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the target
//               node's local position will be copied unaltered.
//////////////////////////////////////////////////////////////////// 6 4 name 1 360  8 duration 1 361  4 node 1 373  6 target 1 373  3 wrt 1 337  9 posOffset 1 376  
66 14 Dtool_ceEZxoqs 0 7 68 385 232 14 Dtool_ceEZxoqs 620 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the position of one node to the position of another.
//
//               If wrt is true, the node's position will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the target
//               node's local position will be copied unaltered.
//////////////////////////////////////////////////////////////////// 5 4 name 1 360  8 duration 1 361  4 node 1 373  6 target 1 373  3 wrt 1 337  
67 14 Dtool_ceEZnovZ 0 6 69 373 0 14 Dtool_ceEZnovZ 754 // Filename: cConstrainPosInterval.I
// Created by:  pratt (29Sep06)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 386  
68 14 Dtool_ceEZIT5k 0 6 70 373 0 14 Dtool_ceEZIT5k 259 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 386  
69 14 Dtool_ceEZHgJb 0 7 71 369 0 14 Dtool_ceEZHgJb 0 0 
70 14 Dtool_ceEZ_uho 0 7 74 388 237 14 Dtool_ceEZ_uho 700 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainTransformInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the transform of one node to the transform of another.
//               To clarify, the transform of node will be copied to target.
//
//               If wrt is true, the node's transform will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the node's
//               local transform will be copied unaltered.
//////////////////////////////////////////////////////////////////// 5 4 name 1 360  8 duration 1 361  4 node 1 373  6 target 1 373  3 wrt 1 337  
71 14 Dtool_ceEZFPOL 0 6 75 373 0 14 Dtool_ceEZFPOL 766 // Filename: cConstrainTransformInterval.I
// Created by:  pratt (29Sep06)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainTransformInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 389  
72 14 Dtool_ceEZu58V 0 6 76 373 0 14 Dtool_ceEZu58V 265 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainTransformInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 389  
73 14 Dtool_ceEZ2uzl 0 7 77 369 0 14 Dtool_ceEZ2uzl 0 0 
74 14 Dtool_ceEZ7SV3 0 7 80 364 239 14 Dtool_ceEZ7SV3 229 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 0 
75 14 Dtool_ceEZH947 0 4 82 363 0 14 Dtool_ceEZH947 1195 // Filename: cIntervalManager.I
// Created by:  drose (10Sep02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::set_event_queue
//       Access: Published
//  Description: Specifies a custom event queue to be used for
//               throwing done events from intervals as they finish.
//               If this is not specified, the global event queue is
//               used.
//
//               The caller maintains ownership of the EventQueue
//               object; it is the caller's responsibility to ensure
//               that the supplied EventQueue does not destruct during
//               the lifetime of the CIntervalManager.
//////////////////////////////////////////////////////////////////// 2 4 this 3 364  11 event_queue 1 391  
76 14 Dtool_ceEZ4ah3 0 6 83 391 0 14 Dtool_ceEZ4ah3 347 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_event_queue
//       Access: Published
//  Description: Returns the custom event queue to be used for
//               throwing done events from intervals as they finish.
//////////////////////////////////////////////////////////////////// 1 4 this 3 393  
77 14 Dtool_ceEZyh7A 0 6 84 367 0 14 Dtool_ceEZyh7A 1079 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::add_c_interval
//       Access: Published
//  Description: Adds the interval to the manager, and returns a
//               unique index for the interval.  This index will be
//               unique among all the currently added intervals, but
//               not unique across all intervals ever added to the
//               manager.  The maximum index value will never exceed
//               the maximum number of intervals added at any given
//               time.
//
//               If the external flag is true, the interval is
//               understood to also be stored in the scripting
//               language data structures.  In this case, it will be
//               available for information returned by
//               get_next_event() and get_next_removal().  If external
//               is false, the interval's index will never be returned
//               by these two functions.
//////////////////////////////////////////////////////////////////// 3 4 this 3 364  8 interval 1 362  8 external 1 337  
78 14 Dtool_ceEZA0H3 0 6 85 367 0 14 Dtool_ceEZA0H3 356 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::find_c_interval
//       Access: Published
//  Description: Returns the index associated with the named interval,
//               if there is such an interval, or -1 if there is not.
//////////////////////////////////////////////////////////////////// 2 4 this 3 393  4 name 1 360  
79 14 Dtool_ceEZnvsF 0 7 86 362 0 14 Dtool_ceEZnvsF 285 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_c_interval
//       Access: Published
//  Description: Returns the interval associated with the given index.
//////////////////////////////////////////////////////////////////// 2 4 this 3 393  5 index 1 367  
80 14 Dtool_ceEZPxys 0 4 87 363 0 14 Dtool_ceEZPxys 472 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::remove_c_interval
//       Access: Published
//  Description: Removes the indicated interval from the queue
//               immediately.  It will not be returned from
//               get_next_removal(), and none of its pending events,
//               if any, will be returned by get_next_event().
//////////////////////////////////////////////////////////////////// 2 4 this 3 364  5 index 1 367  
81 14 Dtool_ceEZwZTK 0 6 88 367 0 14 Dtool_ceEZwZTK 605 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::interrupt
//       Access: Published
//  Description: Pauses or finishes (removes from the active queue)
//               all intervals tagged with auto_pause or auto_finish
//               set to true.  These are intervals that someone fired
//               up but won't necessarily expect to clean up; they can
//               be interrupted at will when necessary.
//
//               Returns the number of intervals affected.
//////////////////////////////////////////////////////////////////// 1 4 this 3 364  
82 14 Dtool_ceEZW9zD 0 6 89 367 0 14 Dtool_ceEZW9zD 284 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_num_intervals
//       Access: Published
//  Description: Returns the number of currently active intervals.
//////////////////////////////////////////////////////////////////// 1 4 this 3 393  
83 14 Dtool_ceEZrnjb 0 6 90 367 0 14 Dtool_ceEZrnjb 591 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_max_index
//       Access: Published
//  Description: Returns one more than the largest interval index
//               number in the manager.  If you walk through all the
//               values between (0, get_max_index()] and call
//               get_c_interval() on each number, you will retrieve
//               all of the managed intervals (and possibly a number
//               of NULL pointers as well).
//////////////////////////////////////////////////////////////////// 1 4 this 3 393  
84 14 Dtool_ceEZjQ_p 0 4 91 363 0 14 Dtool_ceEZjQ_p 771 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::step
//       Access: Published
//  Description: This should be called every frame to do the
//               processing for all the active intervals.  It will
//               call step_play() for each interval that has been
//               added and that has not yet been removed.
//
//               After each call to step(), the scripting language
//               should call get_next_event() and get_next_removal()
//               repeatedly to process all the high-level
//               (e.g. Python-interval-based) events and to manage the
//               high-level list of intervals.
//////////////////////////////////////////////////////////////////// 1 4 this 3 364  
85 14 Dtool_ceEZgEV_ 0 6 92 367 0 14 Dtool_ceEZgEV_ 911 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_next_event
//       Access: Published
//  Description: This should be called by the scripting language after
//               each call to step().  It returns the index number of
//               the next interval that has events requiring servicing
//               by the scripting language, or -1 if no more intervals
//               have any events pending.
//
//               If this function returns something other than -1, it
//               is the scripting language's responsibility to query
//               the indicated interval for its next event via
//               get_event_index(), and eventually pop_event().
//
//               Then get_next_event() should be called again until it
//               returns -1.
//////////////////////////////////////////////////////////////////// 1 4 this 3 364  
86 14 Dtool_ceEZyDVA 0 6 93 367 0 14 Dtool_ceEZyDVA 694 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_next_removal
//       Access: Published
//  Description: This should be called by the scripting language after
//               each call to step().  It returns the index number of
//               an interval that was recently removed, or -1 if no
//               intervals were removed.
//
//               If this returns something other than -1, the
//               scripting language should clean up its own data
//               structures accordingly, and then call
//               get_next_removal() again.
//////////////////////////////////////////////////////////////////// 1 4 this 3 364  
87 14 Dtool_ceEZJ5QE 0 4 94 363 0 14 Dtool_ceEZJ5QE 224 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 393  3 out 1 365  
88 14 Dtool_ceEZzWze 0 4 95 363 0 14 Dtool_ceEZzWze 223 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::write
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 393  3 out 1 365  
89 14 Dtool_ceEZTP38 0 6 96 364 0 14 Dtool_ceEZTP38 319 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_global_ptr
//       Access: Published, Static
//  Description: Returns the pointer to the one global
//               CIntervalManager object.
//////////////////////////////////////////////////////////////////// 0 
90 14 Dtool_ceEZg1iu 0 6 99 344 0 14 Dtool_ceEZg1iu 411 ////////////////////////////////////////////////////////////////////
//     Function: CLerpInterval::get_blend_type
//       Access: Published
//  Description: Returns the blend type specified for the interval.
//               This controls how the linear interpolation behaves
//               near the beginning and end of the lerp period.
//////////////////////////////////////////////////////////////////// 1 4 this 3 395  
91 14 Dtool_ceEZHWfc 0 6 100 344 0 14 Dtool_ceEZHWfc 403 ////////////////////////////////////////////////////////////////////
//     Function: CLerpInterval::string_blend_type
//       Access: Published, Static
//  Description: Returns the BlendType enumerated value corresponding
//               to the indicated string, or BT_invalid if the string
//               doesn't match anything.
//////////////////////////////////////////////////////////////////// 1 10 blend_type 1 360  
92 14 Dtool_ceEZFioW 0 7 101 369 0 14 Dtool_ceEZFioW 0 0 
93 14 Dtool_ceEZZ1mi 0 7 104 397 262 14 Dtool_ceEZZ1mi 735 // Filename: cLerpAnimEffectInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CLerpAnimEffectInterval::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 name 1 360  8 duration 1 361  10 blend_type 1 344  
94 14 Dtool_ceEZPyvp 0 4 105 363 0 14 Dtool_ceEZPyvp 573 ////////////////////////////////////////////////////////////////////
//     Function: CLerpAnimEffectInterval::add_control
//       Access: Published
//  Description: Adds another AnimControl to the list of AnimControls
//               affected by the lerp.  This control will be lerped
//               from begin_effect to end_effect over the period of
//               the lerp.
//
//               The AnimControl name parameter is only used when
//               formatting the interval for output.
//////////////////////////////////////////////////////////////////// 5 4 this 3 397  7 control 1 398  4 name 1 360  12 begin_effect 1 400  10 end_effect 1 400  
95 14 Dtool_ceEZxulU 0 7 106 369 0 14 Dtool_ceEZxulU 0 0 
96 14 Dtool_ceEZdIA4 0 7 109 401 290 14 Dtool_ceEZdIA4 1792 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::Constructor
//       Access: Published
//  Description: Constructs a lerp interval that will lerp some
//               properties on the indicated node, possibly relative
//               to the indicated other node (if other is nonempty).
//
//               You must call set_end_pos(), etc. for the various
//               properties you wish to lerp before the first call to
//               priv_initialize().  If you want to set a starting value
//               for any of the properties, you may call
//               set_start_pos(), etc.; otherwise, the starting value
//               is taken from the actual node's value at the time the
//               lerp is performed.
//
//               The starting values may be explicitly specified or
//               omitted.  The value of bake_in_start determines the
//               behavior if the starting values are omitted.  If
//               bake_in_start is true, the values are obtained the
//               first time the lerp runs, and thenceforth are stored
//               within the interval.  If bake_in_start is false, the
//               starting value is computed each frame, based on
//               assuming the current value represents the value set
//               from the last time the interval was run.  This
//               "smart" behavior allows code to manipulate the object
//               event while it is being lerped, and the lerp
//               continues to apply in a sensible way.
//
//               If fluid is true, the prev_transform is not adjusted
//               by the lerp; otherwise, it is reset.
//////////////////////////////////////////////////////////////////// 7 4 name 1 360  8 duration 1 361  10 blend_type 1 344  13 bake_in_start 1 337  5 fluid 1 337  4 node 1 373  5 other 1 373  
97 14 Dtool_ceEZ9PvW 0 6 110 373 0 14 Dtool_ceEZ9PvW 758 // Filename: cLerpNodePathInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::get_node
//       Access: Published
//  Description: Returns the node being lerped.
//////////////////////////////////////////////////////////////////// 1 4 this 3 402  
98 14 Dtool_ceEZSM_v 0 6 111 373 0 14 Dtool_ceEZSM_v 451 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::get_other
//       Access: Published
//  Description: Returns the "other" node, which the lerped node is
//               being moved relative to.  If this is an empty node
//               path, the lerped node is being moved in its own
//               coordinate system.
//////////////////////////////////////////////////////////////////// 1 4 this 3 402  
99 14 Dtool_ceEZaRxY 0 4 112 363 0 14 Dtool_ceEZaRxY 547 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_pos
//       Access: Published
//  Description: Indicates the initial position of the lerped node.
//               This is meaningful only if set_end_pos() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               position at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  3 pos 1 376  
100 14 Dtool_ceEZJiNY 0 4 113 363 0 14 Dtool_ceEZJiNY 531 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_pos
//       Access: Published
//  Description: Indicates that the position of the node should be
//               lerped, and specifies the final position of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's position will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  3 pos 1 376  
101 14 Dtool_ceEZlyYW 0 4 114 363 0 14 Dtool_ceEZlyYW 589 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_hpr
//       Access: Published
//  Description: Indicates the initial rotation of the lerped node.
//               This is meaningful only if either set_end_hpr() or
//               set_end_quat() is also called.  This parameter is
//               optional; if unspecified, the value will be taken
//               from the node's actual rotation at the time the lerp
//               is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  3 hpr 1 376  
102 14 Dtool_ceEZRVh4 0 4 115 363 0 14 Dtool_ceEZRVh4 735 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_hpr
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This special function is overloaded to accept a
//               quaternion, even though the function name is
//               set_end_hpr().  The quaternion will be implicitly
//               converted to a HPR trio, and the lerp will be
//               performed in HPR space, componentwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  4 quat 1 404  
103 14 Dtool_ceEZrohJ 0 4 115 363 0 14 Dtool_ceEZrohJ 632 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_hpr
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_quat().  If
//               neither set_end_hpr() nor set_end_quat() is called,
//               the node's rotation will not be affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  3 hpr 1 376  
104 14 Dtool_ceEZc5Xe 0 4 116 363 0 14 Dtool_ceEZc5Xe 590 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_quat
//       Access: Published
//  Description: Indicates the initial rotation of the lerped node.
//               This is meaningful only if either set_end_quat() or
//               set_end_hpr() is also called.  This parameter is
//               optional; if unspecified, the value will be taken
//               from the node's actual rotation at the time the lerp
//               is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  4 quat 1 404  
105 14 Dtool_ceEZt__n 0 4 117 363 0 14 Dtool_ceEZt__n 632 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_quat
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_hpr().  If
//               neither set_end_quat() nor set_end_hpr() is called,
//               the node's rotation will not be affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  4 quat 1 404  
106 14 Dtool_ceEZGCRI 0 4 117 363 0 14 Dtool_ceEZGCRI 955 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_quat
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_hpr().  If
//               neither set_end_quat() nor set_end_hpr() is called,
//               the node's rotation will not be affected by the lerp.
//
//               This special function is overloaded to accept a HPR
//               trio, even though the function name is
//               set_end_quat().  The HPR will be implicitly converted
//               to a quaternion, and the lerp will be performed in
//               quaternion space, as a spherical lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  3 hpr 1 376  
107 14 Dtool_ceEZPMwu 0 4 118 363 0 14 Dtool_ceEZPMwu 545 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_scale
//       Access: Published
//  Description: Indicates the initial scale of the lerped node.
//               This is meaningful only if set_end_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               scale at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  5 scale 1 376  
108 14 Dtool_ceEZLfsN 0 4 118 363 0 14 Dtool_ceEZLfsN 545 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_scale
//       Access: Published
//  Description: Indicates the initial scale of the lerped node.
//               This is meaningful only if set_end_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               scale at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  5 scale 1 400  
109 14 Dtool_ceEZu_6i 0 4 119 363 0 14 Dtool_ceEZu_6i 524 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_scale
//       Access: Published
//  Description: Indicates that the scale of the node should be
//               lerped, and specifies the final scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's scale will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  5 scale 1 376  
110 14 Dtool_ceEZBCOk 0 4 119 363 0 14 Dtool_ceEZBCOk 524 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_scale
//       Access: Published
//  Description: Indicates that the scale of the node should be
//               lerped, and specifies the final scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's scale will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  5 scale 1 400  
111 14 Dtool_ceEZyKML 0 4 120 363 0 14 Dtool_ceEZyKML 545 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_shear
//       Access: Published
//  Description: Indicates the initial shear of the lerped node.
//               This is meaningful only if set_end_shear() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               shear at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  5 shear 1 376  
112 14 Dtool_ceEZ1jlK 0 4 121 363 0 14 Dtool_ceEZ1jlK 524 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_shear
//       Access: Published
//  Description: Indicates that the shear of the node should be
//               lerped, and specifies the final shear of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's shear will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  5 shear 1 376  
113 14 Dtool_ceEZt8Tw 0 4 122 363 0 14 Dtool_ceEZt8Tw 545 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_color
//       Access: Published
//  Description: Indicates the initial color of the lerped node.
//               This is meaningful only if set_end_color() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               color at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  5 color 1 407  
114 14 Dtool_ceEZUGzY 0 4 123 363 0 14 Dtool_ceEZUGzY 524 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_color
//       Access: Published
//  Description: Indicates that the color of the node should be
//               lerped, and specifies the final color of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's color will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  5 color 1 407  
115 14 Dtool_ceEZJuh7 0 4 124 363 0 14 Dtool_ceEZJuh7 569 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_color_scale
//       Access: Published
//  Description: Indicates the initial color scale of the lerped node.
//               This is meaningful only if set_end_color_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               color scale at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  11 color_scale 1 407  
116 14 Dtool_ceEZUY_S 0 4 125 363 0 14 Dtool_ceEZUY_S 548 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_color_scale
//       Access: Published
//  Description: Indicates that the color scale of the node should be
//               lerped, and specifies the final color scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's color scale will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  11 color_scale 1 407  
117 14 Dtool_ceEZVJm6 0 4 126 363 0 14 Dtool_ceEZVJm6 426 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_texture_stage
//       Access: Published
//  Description: Indicates the texture stage that is adjusted by
//               tex_offset, tex_rotate, and/or tex_scale.  If this is
//               not set, the default is the default texture stage.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  5 stage 1 410  
118 14 Dtool_ceEZQfKP 0 4 127 363 0 14 Dtool_ceEZQfKP 563 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_tex_offset
//       Access: Published
//  Description: Indicates the initial UV offset of the lerped node.
//               This is meaningful only if set_end_tex_offset() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               UV offset at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  10 tex_offset 1 412  
119 14 Dtool_ceEZ_9Uf 0 4 128 363 0 14 Dtool_ceEZ_9Uf 541 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_tex_offset
//       Access: Published
//  Description: Indicates that the UV offset of the node should be
//               lerped, and specifies the final UV offset of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's UV offset will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  10 tex_offset 1 412  
120 14 Dtool_ceEZwlJM 0 4 129 363 0 14 Dtool_ceEZwlJM 563 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_tex_rotate
//       Access: Published
//  Description: Indicates the initial UV rotate of the lerped node.
//               This is meaningful only if set_end_tex_rotate() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               UV rotate at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  10 tex_rotate 1 400  
121 14 Dtool_ceEZp1uF 0 4 130 363 0 14 Dtool_ceEZp1uF 541 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_tex_rotate
//       Access: Published
//  Description: Indicates that the UV rotate of the node should be
//               lerped, and specifies the final UV rotate of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's UV rotate will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  10 tex_rotate 1 400  
122 14 Dtool_ceEZr5am 0 4 131 363 0 14 Dtool_ceEZr5am 559 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_tex_scale
//       Access: Published
//  Description: Indicates the initial UV scale of the lerped node.
//               This is meaningful only if set_end_tex_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               UV scale at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  9 tex_scale 1 412  
123 14 Dtool_ceEZ8QnN 0 4 132 363 0 14 Dtool_ceEZ8QnN 537 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_tex_scale
//       Access: Published
//  Description: Indicates that the UV scale of the node should be
//               lerped, and specifies the final UV scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's UV scale will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  9 tex_scale 1 412  
124 14 Dtool_ceEZaaze 0 4 133 363 0 14 Dtool_ceEZaaze 623 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_override
//       Access: Published
//  Description: Changes the override value that will be associated
//               with any state changes applied by the lerp.  If this
//               lerp is changing state (for instance, a color lerp or
//               a tex matrix lerp), then the new attributes created
//               by this lerp will be assigned the indicated override
//               value when they are applied to the node.
//////////////////////////////////////////////////////////////////// 2 4 this 3 401  8 override 1 367  
125 14 Dtool_ceEZj9kr 0 6 134 367 0 14 Dtool_ceEZj9kr 384 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::get_override
//       Access: Published
//  Description: Returns the override value that will be associated
//               with any state changes applied by the lerp.  See
//               set_override().
//////////////////////////////////////////////////////////////////// 1 4 this 3 402  
126 14 Dtool_ceEZdTLY 0 7 135 369 0 14 Dtool_ceEZdTLY 0 0 
127 14 Dtool_ceEZfll2 0 7 138 415 0 14 Dtool_ceEZfll2 226 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 name 1 360  
128 14 Dtool_ceEZxSCe 0 4 140 363 0 14 Dtool_ceEZxSCe 1201 // Filename: cMetaInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::set_precision
//       Access: Published
//  Description: Indicates the precision with which time measurements
//               are compared.  For numerical accuracy, all
//               floating-point time values are converted to integer
//               values internally by scaling by the precision factor.
//               The larger the number given here, the smaller the
//               delta of time that can be differentiated; the
//               limit is the maximum integer that can be represented
//               in the system.
//////////////////////////////////////////////////////////////////// 2 4 this 3 415  9 precision 1 361  
129 14 Dtool_ceEZ5PcZ 0 6 141 361 0 14 Dtool_ceEZ5PcZ 331 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_precision
//       Access: Published
//  Description: Returns the precision with which time measurements
//               are compared.  See set_precision().
//////////////////////////////////////////////////////////////////// 1 4 this 3 416  
130 14 Dtool_ceEZS3bp 0 4 142 363 0 14 Dtool_ceEZS3bp 314 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::clear_intervals
//       Access: Published
//  Description: Resets the list of intervals and prepares for
//               receiving a new list.
//////////////////////////////////////////////////////////////////// 1 4 this 3 415  
131 14 Dtool_ceEZe1kF 0 6 143 367 0 14 Dtool_ceEZe1kF 647 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::push_level
//       Access: Published
//  Description: Marks the beginning of a nested level of child
//               intervals.  Within the nested level, a RelativeStart
//               time of RS_level_begin refers to the start of the
//               level, and the first interval added within the level
//               is always relative to the start of the level.
//
//               The return value is the index of the def entry
//               created by this push.
//////////////////////////////////////////////////////////////////// 4 4 this 3 415  4 name 1 360  8 rel_time 1 361  6 rel_to 1 348  
132 14 Dtool_ceEZ8fyX 0 6 144 367 0 14 Dtool_ceEZ8fyX 512 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::add_c_interval
//       Access: Published
//  Description: Adds a new CInterval to the list.  The interval will
//               be played when the indicated time (relative to the
//               given point) has been reached.
//
//               The return value is the index of the def entry
//               representing the new interval.
//////////////////////////////////////////////////////////////////// 4 4 this 3 415  10 c_interval 1 362  8 rel_time 1 361  6 rel_to 1 348  
133 14 Dtool_ceEZhhyN 0 6 144 367 0 14 Dtool_ceEZhhyN 512 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::add_c_interval
//       Access: Published
//  Description: Adds a new CInterval to the list.  The interval will
//               be played when the indicated time (relative to the
//               given point) has been reached.
//
//               The return value is the index of the def entry
//               representing the new interval.
//////////////////////////////////////////////////////////////////// 3 4 this 3 415  10 c_interval 1 362  8 rel_time 1 361  
134 14 Dtool_ceEZHpFi 0 6 144 367 0 14 Dtool_ceEZHpFi 512 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::add_c_interval
//       Access: Published
//  Description: Adds a new CInterval to the list.  The interval will
//               be played when the indicated time (relative to the
//               given point) has been reached.
//
//               The return value is the index of the def entry
//               representing the new interval.
//////////////////////////////////////////////////////////////////// 2 4 this 3 415  10 c_interval 1 362  
135 14 Dtool_ceEZsI0L 0 6 145 367 0 14 Dtool_ceEZsI0L 1156 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::add_ext_index
//       Access: Published
//  Description: Adds a new external interval to the list.  This
//               represents some object in the external scripting
//               language that has properties similar to a CInterval
//               (for instance, a Python Interval object).
//
//               The CMetaInterval object cannot play this external
//               interval directly, but it records a placeholder for
//               it and will ask the scripting language to play it
//               when it is time, via is_event_ready() and related
//               methods.
//
//               The ext_index number itself is simply a handle that
//               the scripting language makes up and associates with
//               its interval object somehow.  The CMetaInterval
//               object does not attempt to interpret this value.
//
//               The return value is the index of the def entry
//               representing the new interval.
//////////////////////////////////////////////////////////////////// 7 4 this 3 415  9 ext_index 1 367  4 name 1 360  8 duration 1 361  10 open_ended 1 337  8 rel_time 1 361  6 rel_to 1 348  
136 14 Dtool_ceEZAQho 0 6 146 367 0 14 Dtool_ceEZAQho 645 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::pop_level
//       Access: Published
//  Description: Finishes a level marked by a previous call to
//               push_level(), and returns to the previous level.
//
//               If the duration is not negative, it represents a
//               phony duration to assign to the level, for the
//               purposes of sequencing later intervals.  Otherwise,
//               the level's duration is computed based on the
//               intervals within the level.
//////////////////////////////////////////////////////////////////// 2 4 this 3 415  8 duration 1 361  
137 14 Dtool_ceEZcB29 0 6 146 367 0 14 Dtool_ceEZcB29 645 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::pop_level
//       Access: Published
//  Description: Finishes a level marked by a previous call to
//               push_level(), and returns to the previous level.
//
//               If the duration is not negative, it represents a
//               phony duration to assign to the level, for the
//               purposes of sequencing later intervals.  Otherwise,
//               the level's duration is computed based on the
//               intervals within the level.
//////////////////////////////////////////////////////////////////// 1 4 this 3 415  
138 14 Dtool_ceEZbNvh 0 6 147 337 0 14 Dtool_ceEZbNvh 824 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::set_interval_start_time
//       Access: Published
//  Description: Adjusts the start time of the child interval with the
//               given name, if found.  This may be either a C++
//               interval added via add_c_interval(), or an external
//               interval added via add_ext_index(); the name must
//               match exactly.
//
//               If the interval is found, its start time is adjusted,
//               and all subsequent intervals are adjusting
//               accordingly, and true is returned.  If a matching
//               interval is not found, nothing is changed and false
//               is returned.
//////////////////////////////////////////////////////////////////// 4 4 this 3 415  4 name 1 360  8 rel_time 1 361  6 rel_to 1 348  
139 14 Dtool_ceEZDRqF 0 6 147 337 0 14 Dtool_ceEZDRqF 824 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::set_interval_start_time
//       Access: Published
//  Description: Adjusts the start time of the child interval with the
//               given name, if found.  This may be either a C++
//               interval added via add_c_interval(), or an external
//               interval added via add_ext_index(); the name must
//               match exactly.
//
//               If the interval is found, its start time is adjusted,
//               and all subsequent intervals are adjusting
//               accordingly, and true is returned.  If a matching
//               interval is not found, nothing is changed and false
//               is returned.
//////////////////////////////////////////////////////////////////// 3 4 this 3 415  4 name 1 360  8 rel_time 1 361  
140 14 Dtool_ceEZnjRJ 0 6 148 361 0 14 Dtool_ceEZnjRJ 451 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_interval_start_time
//       Access: Published
//  Description: Returns the actual start time, relative to the
//               beginning of the interval, of the child interval with
//               the given name, if found, or -1 if the interval is
//               not found.
//////////////////////////////////////////////////////////////////// 2 4 this 3 416  4 name 1 360  
141 14 Dtool_ceEZwxHv 0 6 149 361 0 14 Dtool_ceEZwxHv 447 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_interval_end_time
//       Access: Published
//  Description: Returns the actual end time, relative to the
//               beginning of the interval, of the child interval with
//               the given name, if found, or -1 if the interval is
//               not found.
//////////////////////////////////////////////////////////////////// 2 4 this 3 416  4 name 1 360  
142 14 Dtool_ceEZ4MwM 0 6 151 367 0 14 Dtool_ceEZ4MwM 359 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_num_defs
//       Access: Published
//  Description: Returns the number of interval and push/pop
//               definitions that have been added to the meta
//               interval.
//////////////////////////////////////////////////////////////////// 1 4 this 3 416  
143 14 Dtool_ceEZleqy 0 6 152 349 0 14 Dtool_ceEZleqy 312 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_def_type
//       Access: Published
//  Description: Returns the type of the nth interval definition that
//               has been added.
//////////////////////////////////////////////////////////////////// 2 4 this 3 416  1 n 1 367  
144 14 Dtool_ceEZlcyM 0 7 153 362 0 14 Dtool_ceEZlcyM 409 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_c_interval
//       Access: Published
//  Description: Return the CInterval pointer associated with the nth
//               interval definition.  It is only valid to call this
//               if get_def_type(n) returns DT_c_interval.
//////////////////////////////////////////////////////////////////// 2 4 this 3 416  1 n 1 367  
145 14 Dtool_ceEZDZwS 0 6 154 367 0 14 Dtool_ceEZDZwS 420 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_ext_index
//       Access: Published
//  Description: Return the external interval index number associated
//               with the nth interval definition.  It is only valid
//               to call this if get_def_type(n) returns DT_ext_index.
//////////////////////////////////////////////////////////////////// 2 4 this 3 416  1 n 1 367  
146 14 Dtool_ceEZG_g4 0 6 155 337 0 14 Dtool_ceEZG_g4 544 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::is_event_ready
//       Access: Published
//  Description: Returns true if a recent call to priv_initialize(),
//               priv_step(), or priv_finalize() has left some external
//               intervals ready to play.  If this returns true, call
//               get_event_index(), get_event_t(), and pop_event() to
//               retrieve the relevant information.
//////////////////////////////////////////////////////////////////// 1 4 this 3 415  
147 14 Dtool_ceEZdJvv 0 6 156 367 0 14 Dtool_ceEZdJvv 444 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_index
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the index number (added via
//               add_event_index()) of the external interval that needs
//               to be played.
//////////////////////////////////////////////////////////////////// 1 4 this 3 416  
148 14 Dtool_ceEZPQNU 0 6 157 361 0 14 Dtool_ceEZPQNU 380 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_t
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the t value that should be fed to
//               the given interval.
//////////////////////////////////////////////////////////////////// 1 4 this 3 416  
149 14 Dtool_ceEZsP8v 0 6 158 334 0 14 Dtool_ceEZsP8v 410 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_type
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the type of the event (initialize,
//               step, finalize, etc.) for the given interval.
//////////////////////////////////////////////////////////////////// 1 4 this 3 416  
150 14 Dtool_ceEZ4v7o 0 4 159 363 0 14 Dtool_ceEZ4v7o 591 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::pop_event
//       Access: Published
//  Description: Acknowledges that the external interval on the top of
//               the queue has been extracted, and is about to be
//               serviced by the scripting language.  This prepares
//               the interval so the next call to is_event_ready()
//               will return information about the next external
//               interval on the queue, if any.
//////////////////////////////////////////////////////////////////// 1 4 this 3 415  
151 14 Dtool_ceEZXzrj 0 4 160 363 0 14 Dtool_ceEZXzrj 302 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::timeline
//       Access: Published
//  Description: Outputs a list of all events in the order in which
//               they occur.
//////////////////////////////////////////////////////////////////// 2 4 this 3 416  3 out 1 365  
152 14 Dtool_ceEZQy_U 0 7 161 369 0 14 Dtool_ceEZQy_U 0 0 
153 14 Dtool_ceEZVO63 0 7 163 418 315 14 Dtool_ceEZVO63 225 ////////////////////////////////////////////////////////////////////
//     Function: HideInterval::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 node 1 373  4 name 1 360  
154 14 Dtool_ceEZ866V 0 7 163 418 315 14 Dtool_ceEZ866V 225 ////////////////////////////////////////////////////////////////////
//     Function: HideInterval::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 node 1 373  
155 14 Dtool_ceEZVV6X 0 7 164 369 0 14 Dtool_ceEZVV6X 0 0 
156 14 Dtool_ceEZzKhT 0 6 167 400 0 14 Dtool_ceEZzKhT 0 2 4 this 3 419  6 param0 0 400  
157 14 Dtool_ceEZ1CYW 0 7 168 369 0 14 Dtool_ceEZ1CYW 27 // now for typehandle stuff 0 
158 14 Dtool_ceEZtdxY 0 7 170 420 0 14 Dtool_ceEZtdxY 0 0 
159 14 Dtool_ceEZ1xwc 0 7 171 369 0 14 Dtool_ceEZ1xwc 27 // now for typehandle stuff 0 
160 14 Dtool_ceEZACbp 0 7 173 421 0 14 Dtool_ceEZACbp 0 0 
161 14 Dtool_ceEZ6XjB 0 7 174 369 0 14 Dtool_ceEZ6XjB 27 // now for typehandle stuff 0 
162 14 Dtool_ceEZgLjm 0 7 176 422 0 14 Dtool_ceEZgLjm 0 0 
163 14 Dtool_ceEZq6CW 0 7 177 369 0 14 Dtool_ceEZq6CW 27 // now for typehandle stuff 0 
164 14 Dtool_ceEZ1n4q 0 7 179 423 0 14 Dtool_ceEZ1n4q 0 0 
165 14 Dtool_ceEZjFol 0 7 180 369 0 14 Dtool_ceEZjFol 27 // now for typehandle stuff 0 
166 14 Dtool_ceEZNLk_ 0 7 182 424 328 14 Dtool_ceEZNLk_ 225 ////////////////////////////////////////////////////////////////////
//     Function: ShowInterval::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 node 1 373  4 name 1 360  
167 14 Dtool_ceEZxxld 0 7 182 424 328 14 Dtool_ceEZxxld 225 ////////////////////////////////////////////////////////////////////
//     Function: ShowInterval::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 node 1 373  
168 14 Dtool_ceEZ1PEe 0 7 183 369 0 14 Dtool_ceEZ1PEe 0 0 
169 14 Dtool_ceEZJUNH 0 7 186 425 331 14 Dtool_ceEZJUNH 827 // Filename: waitInterval.I
// Created by:  drose (12Sep02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: WaitInterval::Constructor
//       Access: Published
//  Description: All Wait intervals have the same name.  No one really
//               cares if their names are unique, after all.
//////////////////////////////////////////////////////////////////// 1 8 duration 1 361  
170 14 Dtool_ceEZowFS 0 7 187 369 0 14 Dtool_ceEZowFS 0 0 
94
332 9 CInterval 0 75777 9 CInterval 9 CInterval 0 0 0 0 0 0 43 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 0 0 1 0 333 0 0 0 2 334 335 780
////////////////////////////////////////////////////////////////////
//       Class : CInterval
// Description : The base class for timeline components.  A CInterval
//               represents a single action, event, or collection of
//               nested intervals that will be performed at some
//               specific time or over a period of time.
//
//               This is essentially similar to the Python "Interval"
//               class, but it is implemented in C++ (hence the name).
//               Intervals that may be implemented in C++ will inherit
//               from this class; Intervals that must be implemented
//               in Python will inherit from the similar Python class.
////////////////////////////////////////////////////////////////////

333 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 710
////////////////////////////////////////////////////////////////////
//       Class : TypedReferenceCount
// Description : A base class for things which need to inherit from
//               both TypedObject and from ReferenceCount.  It's
//               convenient to define this intermediate base class
//               instead of multiply inheriting from the two classes
//               each time they are needed, so that we can sensibly
//               pass around pointers to things which are both
//               TypedObjects and ReferenceCounters.
//               
//               See also TypedObject for detailed instructions.
////////////////////////////////////////////////////////////////////

334 9 EventType 0 794624 20 CInterval::EventType 20 CInterval::EventType 332 0 0 0 0 0 0 0 0 0 8 13 ET_initialize 24 CInterval::ET_initialize 0 10 ET_instant 21 CInterval::ET_instant 1 7 ET_step 18 CInterval::ET_step 2 11 ET_finalize 22 CInterval::ET_finalize 3 21 ET_reverse_initialize 32 CInterval::ET_reverse_initialize 4 18 ET_reverse_instant 29 CInterval::ET_reverse_instant 5 19 ET_reverse_finalize 30 CInterval::ET_reverse_finalize 6 12 ET_interrupt 23 CInterval::ET_interrupt 7 0 0

335 5 State 0 794624 16 CInterval::State 16 CInterval::State 332 0 0 0 0 0 0 0 0 0 4 9 S_initial 20 CInterval::S_initial 0 9 S_started 20 CInterval::S_started 1 8 S_paused 19 CInterval::S_paused 2 7 S_final 18 CInterval::S_final 3 0 0

336 19 CConstraintInterval 0 141313 19 CConstraintInterval 19 CConstraintInterval 0 0 0 0 217 1 426 1 216 0 0 1 0 332 0 0 0 0 300
////////////////////////////////////////////////////////////////////
//       Class : CConstraintInterval
// Description : The base class for a family of intervals that
//               constrain some property to a value over time.
////////////////////////////////////////////////////////////////////

337 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

338 21 CConstrainHprInterval 0 141313 21 CConstrainHprInterval 21 CConstrainHprInterval 0 0 0 1 218 222 0 3 219 220 221 0 0 1 0 336 0 0 0 0 311
////////////////////////////////////////////////////////////////////
//       Class : CConstrainHprInterval
// Description : A constraint interval that will constrain the
//               orientation of one node to the orientation of another.
////////////////////////////////////////////////////////////////////

339 24 CConstrainPosHprInterval 0 141313 24 CConstrainPosHprInterval 24 CConstrainPosHprInterval 0 0 0 1 223 227 0 3 224 225 226 0 0 1 0 336 0 0 0 0 357
////////////////////////////////////////////////////////////////////
//       Class : CConstrainPosHprInterval
// Description : A constraint interval that will constrain the
//               position and orientation of one node to the
//               position and orientation of another.
////////////////////////////////////////////////////////////////////

340 21 CConstrainPosInterval 0 141313 21 CConstrainPosInterval 21 CConstrainPosInterval 0 0 0 1 228 232 0 3 229 230 231 0 0 1 0 336 0 0 0 0 305
////////////////////////////////////////////////////////////////////
//       Class : CConstrainPosInterval
// Description : A constraint interval that will constrain the
//               position of one node to the position of another.
////////////////////////////////////////////////////////////////////

341 27 CConstrainTransformInterval 0 141313 27 CConstrainTransformInterval 27 CConstrainTransformInterval 0 0 0 1 233 237 0 3 234 235 236 0 0 1 0 336 0 0 0 0 313
////////////////////////////////////////////////////////////////////
//       Class : CConstrainTransformInterval
// Description : A constraint interval that will constrain the
//               transform of one node to the transform of another.
////////////////////////////////////////////////////////////////////

342 16 CIntervalManager 0 26625 16 CIntervalManager 16 CIntervalManager 0 0 0 1 238 239 0 15 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 0 0 0 0 0 777
////////////////////////////////////////////////////////////////////
//       Class : CIntervalManager
// Description : This object holds a number of currently-playing
//               intervals and is responsible for advancing them each
//               frame as needed.
//
//               There is normally only one IntervalManager object in
//               the world, and it is the responsibility of the
//               scripting language to call step() on this object once
//               each frame, and to then process the events indicated by
//               get_next_event().  
//
//               It is also possible to create multiple
//               IntervalManager objects for special needs.
////////////////////////////////////////////////////////////////////

343 13 CLerpInterval 0 141313 13 CLerpInterval 13 CLerpInterval 0 0 0 0 258 0 3 255 256 257 0 0 1 0 332 0 0 0 1 344 324
////////////////////////////////////////////////////////////////////
//       Class : CLerpInterval
// Description : The base class for a family of intervals that
//               linearly interpolate one or more numeric values over
//               time.
////////////////////////////////////////////////////////////////////

344 9 BlendType 0 794624 24 CLerpInterval::BlendType 24 CLerpInterval::BlendType 343 0 0 0 0 0 0 0 0 0 5 11 BT_no_blend 26 CLerpInterval::BT_no_blend 0 10 BT_ease_in 25 CLerpInterval::BT_ease_in 1 11 BT_ease_out 26 CLerpInterval::BT_ease_out 2 14 BT_ease_in_out 29 CLerpInterval::BT_ease_in_out 3 10 BT_invalid 25 CLerpInterval::BT_invalid 4 0 0

345 23 CLerpAnimEffectInterval 0 141313 23 CLerpAnimEffectInterval 23 CLerpAnimEffectInterval 0 0 0 1 259 262 0 2 260 261 0 0 1 0 343 0 0 0 0 649
////////////////////////////////////////////////////////////////////
//       Class : CLerpAnimEffectInterval
// Description : This interval lerps between different amounts of
//               control effects for various AnimControls that might
//               be playing on an actor.  It's used to change the
//               blending amount between multiple animations.
//
//               The idea is to start all the animations playing
//               first, then use a CLerpAnimEffectInterval to adjust
//               the degree to which each animation affects the actor.
////////////////////////////////////////////////////////////////////

346 21 CLerpNodePathInterval 0 141313 21 CLerpNodePathInterval 21 CLerpNodePathInterval 0 0 0 1 263 290 0 26 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 0 0 1 0 343 0 0 0 0 303
////////////////////////////////////////////////////////////////////
//       Class : CLerpNodePathInterval
// Description : An interval that lerps one or more properties (like
//               pos, hpr, etc.) on a NodePath over time.
////////////////////////////////////////////////////////////////////

347 13 CMetaInterval 0 75777 13 CMetaInterval 13 CMetaInterval 0 0 0 1 291 0 0 21 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 0 0 1 0 332 0 0 0 2 348 349 0

348 13 RelativeStart 0 794624 28 CMetaInterval::RelativeStart 28 CMetaInterval::RelativeStart 347 0 0 0 0 0 0 0 0 0 3 15 RS_previous_end 30 CMetaInterval::RS_previous_end 0 17 RS_previous_begin 32 CMetaInterval::RS_previous_begin 1 14 RS_level_begin 29 CMetaInterval::RS_level_begin 2 0 0

349 7 DefType 0 794624 22 CMetaInterval::DefType 22 CMetaInterval::DefType 347 0 0 0 0 0 0 0 0 0 4 13 DT_c_interval 28 CMetaInterval::DT_c_interval 0 12 DT_ext_index 27 CMetaInterval::DT_ext_index 1 13 DT_push_level 28 CMetaInterval::DT_push_level 2 12 DT_pop_level 27 CMetaInterval::DT_pop_level 3 0 0

350 12 HideInterval 0 141313 12 HideInterval 12 HideInterval 0 0 0 1 313 315 0 1 314 0 0 1 0 332 0 0 0 0 225
////////////////////////////////////////////////////////////////////
//       Class : HideInterval
// Description : An interval that calls NodePath::hide().
////////////////////////////////////////////////////////////////////

351 13 LerpBlendType 0 75777 13 LerpBlendType 13 LerpBlendType 0 0 0 0 0 0 2 316 317 0 0 1 0 333 0 0 0 0 0

352 15 EaseInBlendType 0 75777 15 EaseInBlendType 15 EaseInBlendType 0 0 0 1 318 0 0 1 319 0 0 1 0 351 0 0 0 0 0

353 16 EaseOutBlendType 0 75777 16 EaseOutBlendType 16 EaseOutBlendType 0 0 0 1 320 0 0 1 321 0 0 1 0 351 0 0 0 0 0

354 18 EaseInOutBlendType 0 75777 18 EaseInOutBlendType 18 EaseInOutBlendType 0 0 0 1 322 0 0 1 323 0 0 1 0 351 0 0 0 0 0

355 11 NoBlendType 0 75777 11 NoBlendType 11 NoBlendType 0 0 0 1 324 0 0 1 325 0 0 1 0 351 0 0 0 0 0

356 12 ShowInterval 0 141313 12 ShowInterval 12 ShowInterval 0 0 0 1 326 328 0 1 327 0 0 1 0 332 0 0 0 0 225
////////////////////////////////////////////////////////////////////
//       Class : ShowInterval
// Description : An interval that calls NodePath::show().
////////////////////////////////////////////////////////////////////

357 12 WaitInterval 0 141313 12 WaitInterval 12 WaitInterval 0 0 0 1 329 331 0 1 330 0 0 1 0 332 0 0 0 0 338
////////////////////////////////////////////////////////////////////
//       Class : WaitInterval
// Description : This interval does absolutely nothing, and is mainly
//               useful for marking time between other intervals
//               within a sequence.
////////////////////////////////////////////////////////////////////

358 17 CInterval const * 0 8576 17 CInterval const * 17 CInterval const * 0 0 359 0 0 0 0 0 0 0 0 0 0

359 15 CInterval const 0 8832 15 CInterval const 15 CInterval const 0 0 332 0 0 0 0 0 0 0 0 0 0

360 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

361 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

362 11 CInterval * 0 8576 11 CInterval * 11 CInterval * 0 0 332 0 0 0 0 0 0 0 0 0 0

363 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

364 18 CIntervalManager * 0 8576 18 CIntervalManager * 18 CIntervalManager * 0 0 342 0 0 0 0 0 0 0 0 0 0

365 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 366 0 0 0 0 0 0 0 0 0 0

366 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

367 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

368 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 1098
////////////////////////////////////////////////////////////////////
//       Class : TypeHandle
// Description : TypeHandle is the identifier used to differentiate
//               C++ class types.  Any C++ classes that inherit from
//               some base class, and must be differentiated at run
//               time, should store a static TypeHandle object that
//               can be queried through a static member function
//               named get_class_type().  Most of the time, it is also
//               desirable to inherit from TypedObject, which provides
//               some virtual functions to return the TypeHandle for a
//               particular instance.
//
//               At its essence, a TypeHandle is simply a unique
//               identifier that is assigned by the TypeRegistry.  The
//               TypeRegistry stores a tree of TypeHandles, so that
//               ancestry of a particular type may be queried, and the
//               type name may be retrieved for run-time display.
////////////////////////////////////////////////////////////////////

369 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 368 0 0 0 0 0 0 0 0 0 0

370 27 CConstraintInterval const * 0 8576 27 CConstraintInterval const * 27 CConstraintInterval const * 0 0 371 0 0 0 0 0 0 0 0 0 0

371 25 CConstraintInterval const 0 8832 25 CConstraintInterval const 25 CConstraintInterval const 0 0 336 0 0 0 0 0 0 0 0 0 0

372 21 CConstraintInterval * 0 8576 21 CConstraintInterval * 21 CConstraintInterval * 0 0 336 0 0 0 0 0 0 0 0 0 0

373 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 374 0 0 0 0 0 0 0 0 0 0

374 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 375 0 0 0 0 0 0 0 0 0 0

375 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 2 427 428 0 0 0 0 4938
//
// A NodePath is the fundamental unit of high-level interaction with
// the scene graph.  It encapsulates the complete path down to a node
// from some other node, usually the root of the scene graph.  This is
// used to resolve ambiguities associated with instancing.
//
// NodePath also contains a number of handy high-level methods for
// common scene-graph manipulations, such as reparenting, and common
// state changes, such as repositioning.
//
// There are also a number of NodePath methods for finding nodes deep
// within the tree by name or by type.  These take a path string,
// which at its simplest consists of a series of node names separated
// by slashes, like a directory pathname.
//
// Each component of the path string may optionally consist of one of
// the following special names, instead of a node name:
//
//   *          -- matches exactly one node, with any name.
//   **         -- matches any sequence of zero or more nodes.
//   +typename  -- matches any node that is or derives from the given type.
//   -typename  -- matches any node that is the given type exactly.
//   =tag       -- matches any node that has the indicated tag.
//   =tag=value -- matches any node whose tag matches the indicated value.
//
// Furthermore, a node name may itself contain standard filename
// globbing characters, like *, ?, and [a-z], that will be accepted as
// a partial match.  (In fact, the '*' special name may be seen as
// just a special case of this.)  The globbing characters may not be
// used with the typename matches or with tag matches, but they may
// be used to match a tag's value in the =tag=value syntax.
//
// The special characters "@@", appearing at the beginning of a node
// name, indicate a stashed node.  Normally, stashed nodes are not
// returned by a find (but see the special flags, below), but a
// stashed node may be found if it is explicitly named with its
// leading @@ characters.  By extension, "@@*" may be used to identify
// any stashed node.
//
// Examples:
//
// "room//graph" will look for a node named "graph", which is a child
// of an unnamed node, which is a child of a node named "room", which
// is a child of the starting path.
//
// "**/red*" will look for any node anywhere in the tree (below the
// starting path) with a name that begins with "red".
//
// "**/+PartBundleNode/**/head" will look for a node named "head",
// somewhere below a PartBundleNode anywhere in the tree.
//
//
// The search is always potentially ambiguous, even if the special
// wildcard operators are not used, because there may be multiple
// nodes in the tree with the same name.  In general, in the case of
// an ambiguity, the shortest path is preferred; when a method (such
// as extend_by) must choose only only one of several possible paths,
// it will choose the shortest available; on the other hand, when a
// method (such as find_all_matches) is to return all of the matching
// paths, it will sort them so that the shortest paths appear first in
// the output.
//
//
// Special flags.  The entire string may optionally be followed by the
// ";" character, followed by one or more of the following special
// control flags, with no intervening spaces or punctuation:
//
//    -h    Do not return hidden nodes.
//    +h    Do return hidden nodes.
//    -s    Do not return stashed nodes unless explicitly referenced with @@.
//    +s    Return stashed nodes even without any explicit @@ characters.
//    -i    Node name comparisons are not case insensitive: case must match
//          exactly.
//    +i    Node name comparisons are case insensitive: case is not important.
//          This affects matches against the node name only; node type
//          and tag strings are always case sensitive.
//
// The default flags are +h-s-i.
//
////////////////////////////////////////////////////////////////////
//       Class : NodePath
// Description : NodePath is the fundamental system for disambiguating
//               instances, and also provides a higher-level interface
//               for manipulating the scene graph.
//
//               A NodePath is a list of connected nodes from the root
//               of the graph to any sub-node.  Each NodePath
//               therefore uniquely describes one instance of a node.
//
//               NodePaths themselves are lightweight objects that may
//               easily be copied and passed by value.  Their data is
//               stored as a series of NodePathComponents that are
//               stored on the nodes.  Holding a NodePath will keep a
//               reference count to all the nodes in the path.
//               However, if any node in the path is removed or
//               reparented (perhaps through a different NodePath),
//               the NodePath will automatically be updated to reflect
//               the changes.
////////////////////////////////////////////////////////////////////

376 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 377 0 0 0 0 0 0 0 0 0 0

377 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 378 0 0 0 0 0 0 0 0 0 0

378 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 754
// Filename: lvecBase3_src.h
// Created by:  drose (08Mar00)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//       Class : LVecBase3
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

379 23 CConstrainHprInterval * 0 8576 23 CConstrainHprInterval * 23 CConstrainHprInterval * 0 0 338 0 0 0 0 0 0 0 0 0 0

380 29 CConstrainHprInterval const * 0 8576 29 CConstrainHprInterval const * 29 CConstrainHprInterval const * 0 0 381 0 0 0 0 0 0 0 0 0 0

381 27 CConstrainHprInterval const 0 8832 27 CConstrainHprInterval const 27 CConstrainHprInterval const 0 0 338 0 0 0 0 0 0 0 0 0 0

382 26 CConstrainPosHprInterval * 0 8576 26 CConstrainPosHprInterval * 26 CConstrainPosHprInterval * 0 0 339 0 0 0 0 0 0 0 0 0 0

383 32 CConstrainPosHprInterval const * 0 8576 32 CConstrainPosHprInterval const * 32 CConstrainPosHprInterval const * 0 0 384 0 0 0 0 0 0 0 0 0 0

384 30 CConstrainPosHprInterval const 0 8832 30 CConstrainPosHprInterval const 30 CConstrainPosHprInterval const 0 0 339 0 0 0 0 0 0 0 0 0 0

385 23 CConstrainPosInterval * 0 8576 23 CConstrainPosInterval * 23 CConstrainPosInterval * 0 0 340 0 0 0 0 0 0 0 0 0 0

386 29 CConstrainPosInterval const * 0 8576 29 CConstrainPosInterval const * 29 CConstrainPosInterval const * 0 0 387 0 0 0 0 0 0 0 0 0 0

387 27 CConstrainPosInterval const 0 8832 27 CConstrainPosInterval const 27 CConstrainPosInterval const 0 0 340 0 0 0 0 0 0 0 0 0 0

388 29 CConstrainTransformInterval * 0 8576 29 CConstrainTransformInterval * 29 CConstrainTransformInterval * 0 0 341 0 0 0 0 0 0 0 0 0 0

389 35 CConstrainTransformInterval const * 0 8576 35 CConstrainTransformInterval const * 35 CConstrainTransformInterval const * 0 0 390 0 0 0 0 0 0 0 0 0 0

390 33 CConstrainTransformInterval const 0 8832 33 CConstrainTransformInterval const 33 CConstrainTransformInterval const 0 0 341 0 0 0 0 0 0 0 0 0 0

391 12 EventQueue * 0 8576 12 EventQueue * 12 EventQueue * 0 0 392 0 0 0 0 0 0 0 0 0 0

392 10 EventQueue 0 2048 10 EventQueue 10 EventQueue 0 0 0 0 0 0 0 0 0 0 0 0 392
////////////////////////////////////////////////////////////////////
//       Class : EventQueue
// Description : A queue of pending events.  As events are thrown,
//               they are added to this queue; eventually, they will
//               be extracted out again by an EventHandler and
//               processed.
////////////////////////////////////////////////////////////////////

393 24 CIntervalManager const * 0 8576 24 CIntervalManager const * 24 CIntervalManager const * 0 0 394 0 0 0 0 0 0 0 0 0 0

394 22 CIntervalManager const 0 8832 22 CIntervalManager const 22 CIntervalManager const 0 0 342 0 0 0 0 0 0 0 0 0 0

395 21 CLerpInterval const * 0 8576 21 CLerpInterval const * 21 CLerpInterval const * 0 0 396 0 0 0 0 0 0 0 0 0 0

396 19 CLerpInterval const 0 8832 19 CLerpInterval const 19 CLerpInterval const 0 0 343 0 0 0 0 0 0 0 0 0 0

397 25 CLerpAnimEffectInterval * 0 8576 25 CLerpAnimEffectInterval * 25 CLerpAnimEffectInterval * 0 0 345 0 0 0 0 0 0 0 0 0 0

398 13 AnimControl * 0 8576 13 AnimControl * 13 AnimControl * 0 0 399 0 0 0 0 0 0 0 0 0 0

399 11 AnimControl 0 2048 11 AnimControl 11 AnimControl 0 0 0 0 0 0 0 0 0 0 0 0 487
////////////////////////////////////////////////////////////////////
//       Class : AnimControl
// Description : Controls the timing of a character animation.  An
//               AnimControl object is created for each
//               character/bundle binding and manages the state of the
//               animation: whether started, stopped, or looping, and
//               the current frame number and play rate.
////////////////////////////////////////////////////////////////////

400 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

401 23 CLerpNodePathInterval * 0 8576 23 CLerpNodePathInterval * 23 CLerpNodePathInterval * 0 0 346 0 0 0 0 0 0 0 0 0 0

402 29 CLerpNodePathInterval const * 0 8576 29 CLerpNodePathInterval const * 29 CLerpNodePathInterval const * 0 0 403 0 0 0 0 0 0 0 0 0 0

403 27 CLerpNodePathInterval const 0 8832 27 CLerpNodePathInterval const 27 CLerpNodePathInterval const 0 0 346 0 0 0 0 0 0 0 0 0 0

404 20 LQuaternionf const * 0 8576 20 LQuaternionf const * 20 LQuaternionf const * 0 0 405 0 0 0 0 0 0 0 0 0 0

405 18 LQuaternionf const 0 8832 18 LQuaternionf const 18 LQuaternionf const 0 0 406 0 0 0 0 0 0 0 0 0 0

406 12 LQuaternionf 0 2048 12 LQuaternionf 12 LQuaternionf 0 0 0 0 0 0 0 0 0 0 0 0 719
// Filename: lquaternion_src.h
// Created by:  frang (06Jun00)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//       Class : FLOATNAME(LQuaternion)
// Description : This is the base quaternion class
////////////////////////////////////////////////////////////////////

407 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 408 0 0 0 0 0 0 0 0 0 0

408 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 409 0 0 0 0 0 0 0 0 0 0

409 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase4
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

410 14 TextureStage * 0 8576 14 TextureStage * 14 TextureStage * 0 0 411 0 0 0 0 0 0 0 0 0 0

411 12 TextureStage 0 2048 12 TextureStage 12 TextureStage 0 0 0 0 0 0 0 0 0 0 0 0 600
////////////////////////////////////////////////////////////////////
//       Class : TextureStage
// Description : Defines the properties of a named stage of the
//               multitexture pipeline.  The TextureAttrib will
//               associated a number of these stages with Texture
//               objects, and the GSG will render geometry by sorting
//               all of the currently active TextureStages in order
//               and then issuing the appropriate rendering calls to
//               activate them.
////////////////////////////////////////////////////////////////////

412 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 413 0 0 0 0 0 0 0 0 0 0

413 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 414 0 0 0 0 0 0 0 0 0 0

414 10 LVecBase2f 0 2048 10 LVecBase2f 10 LVecBase2f 0 0 0 0 0 0 0 0 0 0 0 0 752
// Filename: lvecBase2_src.h
// Created by:  drose (08Mar00)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//       Class : LVecBase2
// Description : This is the base class for all two-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

415 15 CMetaInterval * 0 8576 15 CMetaInterval * 15 CMetaInterval * 0 0 347 0 0 0 0 0 0 0 0 0 0

416 21 CMetaInterval const * 0 8576 21 CMetaInterval const * 21 CMetaInterval const * 0 0 417 0 0 0 0 0 0 0 0 0 0

417 19 CMetaInterval const 0 8832 19 CMetaInterval const 19 CMetaInterval const 0 0 347 0 0 0 0 0 0 0 0 0 0

418 14 HideInterval * 0 8576 14 HideInterval * 14 HideInterval * 0 0 350 0 0 0 0 0 0 0 0 0 0

419 15 LerpBlendType * 0 8576 15 LerpBlendType * 15 LerpBlendType * 0 0 351 0 0 0 0 0 0 0 0 0 0

420 17 EaseInBlendType * 0 8576 17 EaseInBlendType * 17 EaseInBlendType * 0 0 352 0 0 0 0 0 0 0 0 0 0

421 18 EaseOutBlendType * 0 8576 18 EaseOutBlendType * 18 EaseOutBlendType * 0 0 353 0 0 0 0 0 0 0 0 0 0

422 20 EaseInOutBlendType * 0 8576 20 EaseInOutBlendType * 20 EaseInOutBlendType * 0 0 354 0 0 0 0 0 0 0 0 0 0

423 13 NoBlendType * 0 8576 13 NoBlendType * 13 NoBlendType * 0 0 355 0 0 0 0 0 0 0 0 0 0

424 14 ShowInterval * 0 8576 14 ShowInterval * 14 ShowInterval * 0 0 356 0 0 0 0 0 0 0 0 0 0

425 14 WaitInterval * 0 8576 14 WaitInterval * 14 WaitInterval * 0 0 357 0 0 0 0 0 0 0 0 0 0

0
1
426 14 bogus_variable 0 6 337 214 215 35 CConstraintInterval::bogus_variable 
2
427 0 0 260 9 get_nodes 13 get_num_nodes 8 get_node 
428 0 0 260 13 get_ancestors 13 get_num_nodes 12 get_ancestor 
